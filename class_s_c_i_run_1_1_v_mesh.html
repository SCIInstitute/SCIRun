<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>SCIRun: SCIRun::VMesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SCIRun
   &#160;<span id="projectnumber">5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_s_c_i_run.html">SCIRun</a></li><li class="navelem"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html">VMesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_s_c_i_run_1_1_v_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SCIRun::VMesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for SCIRun::VMesh:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_s_c_i_run_1_1_v_mesh.png" usemap="#SCIRun::VMesh_map" alt=""/>
  <map id="SCIRun::VMesh_map" name="SCIRun::VMesh_map">
<area href="class_s_c_i_run_1_1_v_mesh_shared.html" alt="SCIRun::VMeshShared&lt; MESH &gt;" shape="rect" coords="0,56,232,80"/>
<area href="class_s_c_i_run_1_1_v_unstructured_mesh.html" alt="SCIRun::VUnstructuredMesh&lt; MESH &gt;" shape="rect" coords="0,112,232,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_cell.html">Cell</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_d_elem.html">DElem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for indexing edges.  <a href="class_s_c_i_run_1_1_v_mesh_1_1_edge.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_elem.html">Elem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_elem_gradient.html">ElemGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_elem_interpolate.html">ElemInterpolate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_e_node.html">ENode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_face.html">Face</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for indexing faces.  <a href="class_s_c_i_run_1_1_v_mesh_1_1_face.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a319f4bbc40f3a52f7b1a5d9f072da0ff"><td class="memItemLeft" align="right" valign="top">typedef Mesh::index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a></td></tr>
<tr class="memdesc:a319f4bbc40f3a52f7b1a5d9f072da0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">VIRTUAL INTERFACE.  <a href="#a319f4bbc40f3a52f7b1a5d9f072da0ff">More...</a><br/></td></tr>
<tr class="separator:a319f4bbc40f3a52f7b1a5d9f072da0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf01ef7b7127f0bec3dc0b80e9bbd7b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf01ef7b7127f0bec3dc0b80e9bbd7b1"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#aaf01ef7b7127f0bec3dc0b80e9bbd7b1">weight_type</a></td></tr>
<tr class="memdesc:aaf01ef7b7127f0bec3dc0b80e9bbd7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights for interpolation. <br/></td></tr>
<tr class="separator:aaf01ef7b7127f0bec3dc0b80e9bbd7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9276f9dbec864e9fad74c4309a85ef71"><td class="memItemLeft" align="right" valign="top">typedef Mesh::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a></td></tr>
<tr class="separator:a9276f9dbec864e9fad74c4309a85ef71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66031d97d4b6526941db42af2c796bce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66031d97d4b6526941db42af2c796bce"></a>
typedef std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a66031d97d4b6526941db42af2c796bce">array_type</a></td></tr>
<tr class="memdesc:a66031d97d4b6526941db42af2c796bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of indices. <br/></td></tr>
<tr class="separator:a66031d97d4b6526941db42af2c796bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92441dd5102c545e55eaec85187b6562"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92441dd5102c545e55eaec85187b6562"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a92441dd5102c545e55eaec85187b6562">points_type</a></td></tr>
<tr class="memdesc:a92441dd5102c545e55eaec85187b6562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of points. <br/></td></tr>
<tr class="separator:a92441dd5102c545e55eaec85187b6562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b813c7746a5777053cad48af766af15"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a8b813c7746a5777053cad48af766af15">dimension_type</a></td></tr>
<tr class="separator:a8b813c7746a5777053cad48af766af15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69773be1fc8c5b47a4197be4a2c4aa00"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_s_c_i_run_1_1_stack_vector.html">StackVector</a>&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a></td></tr>
<tr class="separator:a69773be1fc8c5b47a4197be4a2c4aa00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad682e81b4b76f2fb01404e31f92e3bb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad682e81b4b76f2fb01404e31f92e3bb2"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_s_c_i_run_1_1_stack_vector.html">StackVector</a>&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ad682e81b4b76f2fb01404e31f92e3bb2">coords_array_type</a></td></tr>
<tr class="memdesc:ad682e81b4b76f2fb01404e31f92e3bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of coords. <br/></td></tr>
<tr class="separator:ad682e81b4b76f2fb01404e31f92e3bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463c02f0bc5c9bfc08a2147c824b509a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a463c02f0bc5c9bfc08a2147c824b509a"></a>
typedef std::vector<br class="typebreak"/>
&lt; std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_stack_vector.html">StackVector</a><br class="typebreak"/>
&lt; double, 3 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a463c02f0bc5c9bfc08a2147c824b509a">coords_array2_type</a></td></tr>
<tr class="memdesc:a463c02f0bc5c9bfc08a2147c824b509a"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D array of coords <br/></td></tr>
<tr class="separator:a463c02f0bc5c9bfc08a2147c824b509a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6035940e63cb533cb69e5bee63cd53e5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_s_c_i_run_1_1_stack_vector.html">StackVector</a><br class="typebreak"/>
&lt; <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a6035940e63cb533cb69e5bee63cd53e5">dpoints_type</a></td></tr>
<tr class="separator:a6035940e63cb533cb69e5bee63cd53e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7483757f655c7307a2b15c5f09effff"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#aa7483757f655c7307a2b15c5f09effff">mask_type</a></td></tr>
<tr class="separator:aa7483757f655c7307a2b15c5f09effff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312efb2415f3b0119d1d944c4131c312"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">StackBasedVector</a><br class="typebreak"/>
&lt; <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a>, 12 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a312efb2415f3b0119d1d944c4131c312">index_array_type</a></td></tr>
<tr class="separator:a312efb2415f3b0119d1d944c4131c312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9935698f84dbf0dcc4da6a0eeecd2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c9935698f84dbf0dcc4da6a0eeecd2c"></a>
typedef <a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">StackBasedVector</a><br class="typebreak"/>
&lt; double, 12 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>weight_array_type</b></td></tr>
<tr class="separator:a9c9935698f84dbf0dcc4da6a0eeecd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c4e67e0741ac07c6c5969c35839ba0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88c4e67e0741ac07c6c5969c35839ba0"></a>
typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nodes_array_type</b></td></tr>
<tr class="separator:a88c4e67e0741ac07c6c5969c35839ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55178c395525bd261b30c878a0439981"><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_elem_interpolate.html">ElemInterpolate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a55178c395525bd261b30c878a0439981">MultiElemInterpolate</a></td></tr>
<tr class="separator:a55178c395525bd261b30c878a0439981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35d232b06cdad0907657fc830879d2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab35d232b06cdad0907657fc830879d2b"></a>
typedef std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_elem_gradient.html">ElemGradient</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab35d232b06cdad0907657fc830879d2b">MultiElemGradient</a></td></tr>
<tr class="memdesc:ab35d232b06cdad0907657fc830879d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiple gradient calculations in parallel. <br/></td></tr>
<tr class="separator:ab35d232b06cdad0907657fc830879d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3a03c9840d8f57db514691dee8ab3fda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a3a03c9840d8f57db514691dee8ab3fda">VMesh</a> ()</td></tr>
<tr class="separator:a3a03c9840d8f57db514691dee8ab3fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4500ee49d9bd5e482bd36053bfcfa1fb"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a4500ee49d9bd5e482bd36053bfcfa1fb">~VMesh</a> ()</td></tr>
<tr class="separator:a4500ee49d9bd5e482bd36053bfcfa1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08c624c6688736d10289800c8ed5279"><td class="memItemLeft" align="right" valign="top">virtual MeshHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ac08c624c6688736d10289800c8ed5279">mesh</a> ()</td></tr>
<tr class="separator:ac08c624c6688736d10289800c8ed5279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93899b3d1a63c56357435c8533914204"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93899b3d1a63c56357435c8533914204"></a>
<a class="el" href="class_s_c_i_run_1_1_v_mesh.html">VMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a93899b3d1a63c56357435c8533914204">vmesh</a> ()</td></tr>
<tr class="memdesc:a93899b3d1a63c56357435c8533914204"><td class="mdescLeft">&#160;</td><td class="mdescRight">A call to it self. <br/></td></tr>
<tr class="separator:a93899b3d1a63c56357435c8533914204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c8aa089892610ed8bff1ef4776e365"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ad5c8aa089892610ed8bff1ef4776e365">begin</a> (<a class="el" href="struct_s_c_i_run_1_1_v_node_iterator.html">Node::iterator</a> &amp;it) const </td></tr>
<tr class="separator:ad5c8aa089892610ed8bff1ef4776e365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521919b0f30fd6c684aa320bc8bffb5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a521919b0f30fd6c684aa320bc8bffb5e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (<a class="el" href="struct_s_c_i_run_1_1_v_e_node_iterator.html">ENode::iterator</a> &amp;it) const </td></tr>
<tr class="separator:a521919b0f30fd6c684aa320bc8bffb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab945f9652b022cae6546632fb88b2b15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab945f9652b022cae6546632fb88b2b15"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (<a class="el" href="struct_s_c_i_run_1_1_v_edge_iterator.html">Edge::iterator</a> &amp;it) const </td></tr>
<tr class="separator:ab945f9652b022cae6546632fb88b2b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3322e218a3fb67d4a4a03b22fcb2d95d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3322e218a3fb67d4a4a03b22fcb2d95d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (<a class="el" href="struct_s_c_i_run_1_1_v_face_iterator.html">Face::iterator</a> &amp;it) const </td></tr>
<tr class="separator:a3322e218a3fb67d4a4a03b22fcb2d95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad578ef7609c18d0003ad4e8c19c7a865"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad578ef7609c18d0003ad4e8c19c7a865"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (<a class="el" href="struct_s_c_i_run_1_1_v_cell_iterator.html">Cell::iterator</a> &amp;it) const </td></tr>
<tr class="separator:ad578ef7609c18d0003ad4e8c19c7a865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad246b7564ba25e1f009b0b33bf10c4ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad246b7564ba25e1f009b0b33bf10c4ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (<a class="el" href="struct_s_c_i_run_1_1_v_elem_iterator.html">Elem::iterator</a> &amp;it) const </td></tr>
<tr class="separator:ad246b7564ba25e1f009b0b33bf10c4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac484d7184fec7a1cadf2d7377c2aedb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac484d7184fec7a1cadf2d7377c2aedb2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (<a class="el" href="struct_s_c_i_run_1_1_v_d_elem_iterator.html">DElem::iterator</a> &amp;it) const </td></tr>
<tr class="separator:ac484d7184fec7a1cadf2d7377c2aedb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19294845d1c60685d7137adfb2b7edc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa19294845d1c60685d7137adfb2b7edc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (<a class="el" href="struct_s_c_i_run_1_1_v_node_iterator.html">Node::iterator</a> &amp;it) const </td></tr>
<tr class="separator:aa19294845d1c60685d7137adfb2b7edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad773ffe996ef1e587f27e1b7750a89b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad773ffe996ef1e587f27e1b7750a89b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (<a class="el" href="struct_s_c_i_run_1_1_v_e_node_iterator.html">ENode::iterator</a> &amp;it) const </td></tr>
<tr class="separator:ad773ffe996ef1e587f27e1b7750a89b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5bf2273c0a747965d5dc7d94c92ad0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f5bf2273c0a747965d5dc7d94c92ad0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (<a class="el" href="struct_s_c_i_run_1_1_v_edge_iterator.html">Edge::iterator</a> &amp;it) const </td></tr>
<tr class="separator:a7f5bf2273c0a747965d5dc7d94c92ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d71b2ee4048c05537f07c77a0a1be2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d71b2ee4048c05537f07c77a0a1be2a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (<a class="el" href="struct_s_c_i_run_1_1_v_face_iterator.html">Face::iterator</a> &amp;it) const </td></tr>
<tr class="separator:a1d71b2ee4048c05537f07c77a0a1be2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb26f9e6d2b89593eb01a51bac9b3f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4eb26f9e6d2b89593eb01a51bac9b3f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (<a class="el" href="struct_s_c_i_run_1_1_v_cell_iterator.html">Cell::iterator</a> &amp;it) const </td></tr>
<tr class="separator:a4eb26f9e6d2b89593eb01a51bac9b3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4d04a1b60a2532d642f53909af8d91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d4d04a1b60a2532d642f53909af8d91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (<a class="el" href="struct_s_c_i_run_1_1_v_elem_iterator.html">Elem::iterator</a> &amp;it) const </td></tr>
<tr class="separator:a3d4d04a1b60a2532d642f53909af8d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e202d1a8181b8935b0cc49b346999e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e202d1a8181b8935b0cc49b346999e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (<a class="el" href="struct_s_c_i_run_1_1_v_d_elem_iterator.html">DElem::iterator</a> &amp;it) const </td></tr>
<tr class="separator:a4e202d1a8181b8935b0cc49b346999e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96ee649dad57ef154e54b22c282511a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab96ee649dad57ef154e54b22c282511a">size</a> (<a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::size_type</a> &amp;size) const </td></tr>
<tr class="separator:ab96ee649dad57ef154e54b22c282511a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43cc64e624a7add239fc7b17c9b98ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa43cc64e624a7add239fc7b17c9b98ed"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (<a class="el" href="struct_s_c_i_run_1_1_v_e_node_index.html">ENode::size_type</a> &amp;size) const </td></tr>
<tr class="separator:aa43cc64e624a7add239fc7b17c9b98ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2169843495f0064d0c79159865d1210f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2169843495f0064d0c79159865d1210f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (<a class="el" href="struct_s_c_i_run_1_1_v_edge_index.html">Edge::size_type</a> &amp;size) const </td></tr>
<tr class="separator:a2169843495f0064d0c79159865d1210f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8057e31ba88e323874aeb3a3e288830"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8057e31ba88e323874aeb3a3e288830"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (<a class="el" href="struct_s_c_i_run_1_1_v_face_index.html">Face::size_type</a> &amp;size) const </td></tr>
<tr class="separator:ae8057e31ba88e323874aeb3a3e288830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640d47f00a7c5988036c01c24d747126"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a640d47f00a7c5988036c01c24d747126"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (<a class="el" href="struct_s_c_i_run_1_1_v_cell_index.html">Cell::size_type</a> &amp;size) const </td></tr>
<tr class="separator:a640d47f00a7c5988036c01c24d747126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318a630fa2892f21343291252927a2a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a318a630fa2892f21343291252927a2a4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (<a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::size_type</a> &amp;size) const </td></tr>
<tr class="separator:a318a630fa2892f21343291252927a2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1271838b7f6c05770cc94900bbf71c81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1271838b7f6c05770cc94900bbf71c81"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (<a class="el" href="struct_s_c_i_run_1_1_v_d_elem_index.html">DElem::size_type</a> &amp;size) const </td></tr>
<tr class="separator:a1271838b7f6c05770cc94900bbf71c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad973cfb27078f1dbaaf9bbced7ba7b25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ad973cfb27078f1dbaaf9bbced7ba7b25">num_nodes</a> () const </td></tr>
<tr class="separator:ad973cfb27078f1dbaaf9bbced7ba7b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae856bbbca31fe8cc6827d133b0e96dd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae856bbbca31fe8cc6827d133b0e96dd7"></a>
<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>num_enodes</b> () const </td></tr>
<tr class="separator:ae856bbbca31fe8cc6827d133b0e96dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071bff36f94ac746c05ba00e54d3ef23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a071bff36f94ac746c05ba00e54d3ef23"></a>
<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>num_edges</b> () const </td></tr>
<tr class="separator:a071bff36f94ac746c05ba00e54d3ef23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea0bbc0da60e761290c45d4600e88ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeea0bbc0da60e761290c45d4600e88ac"></a>
<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>num_faces</b> () const </td></tr>
<tr class="separator:aeea0bbc0da60e761290c45d4600e88ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa308ea88f8626ce4d19471d10815ac4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa308ea88f8626ce4d19471d10815ac4c"></a>
<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>num_cells</b> () const </td></tr>
<tr class="separator:aa308ea88f8626ce4d19471d10815ac4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e00294eaed908586fe2090836b7775"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73e00294eaed908586fe2090836b7775"></a>
<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>num_elems</b> () const </td></tr>
<tr class="separator:a73e00294eaed908586fe2090836b7775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc573f5d4e10ad378836e60bdfa9a44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcc573f5d4e10ad378836e60bdfa9a44"></a>
<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>num_delems</b> () const </td></tr>
<tr class="separator:afcc573f5d4e10ad378836e60bdfa9a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a703f80e3f4341b573fb6b1916da541"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a703f80e3f4341b573fb6b1916da541"></a>
virtual boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="class_s_c_i_run_1_1_search_grid_t.html">SearchGridT</a><br class="typebreak"/>
&lt; SCIRun::index_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a5a703f80e3f4341b573fb6b1916da541">get_elem_search_grid</a> ()</td></tr>
<tr class="memdesc:a5a703f80e3f4341b573fb6b1916da541"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOTE NOT VALID FOR EACH MESH: <br/></td></tr>
<tr class="separator:a5a703f80e3f4341b573fb6b1916da541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa818b313885bead3c1e6d231d2c13f6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa818b313885bead3c1e6d231d2c13f6e"></a>
virtual boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="class_s_c_i_run_1_1_search_grid_t.html">SearchGridT</a><br class="typebreak"/>
&lt; SCIRun::index_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_node_search_grid</b> ()</td></tr>
<tr class="separator:aa818b313885bead3c1e6d231d2c13f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7979b424a86b11a5e8aa892f2e451936"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a7979b424a86b11a5e8aa892f2e451936">is_empty</a> () const </td></tr>
<tr class="separator:a7979b424a86b11a5e8aa892f2e451936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d686e46a85978bbbcb9d132ab3d299"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a13d686e46a85978bbbcb9d132ab3d299">get_nodes</a> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;nodes, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> i) const </td></tr>
<tr class="separator:a13d686e46a85978bbbcb9d132ab3d299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d5c10c14764302f93bfae5a776febb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25d5c10c14764302f93bfae5a776febb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_nodes</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;nodes, <a class="el" href="struct_s_c_i_run_1_1_v_edge_index.html">Edge::index_type</a> i) const </td></tr>
<tr class="separator:a25d5c10c14764302f93bfae5a776febb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aabb698d360890480f8b37abda91495"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6aabb698d360890480f8b37abda91495"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_nodes</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;nodes, <a class="el" href="struct_s_c_i_run_1_1_v_face_index.html">Face::index_type</a> i) const </td></tr>
<tr class="separator:a6aabb698d360890480f8b37abda91495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fdfacae3a7cbefda63f7faa0ef2095"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72fdfacae3a7cbefda63f7faa0ef2095"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_nodes</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;nodes, <a class="el" href="struct_s_c_i_run_1_1_v_cell_index.html">Cell::index_type</a> i) const </td></tr>
<tr class="separator:a72fdfacae3a7cbefda63f7faa0ef2095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9162d9ebca3b6b18d445e538615b1e67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9162d9ebca3b6b18d445e538615b1e67"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_nodes</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;nodes, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="separator:a9162d9ebca3b6b18d445e538615b1e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17da709840ba439292c656d7a24ec460"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17da709840ba439292c656d7a24ec460"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_nodes</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;nodes, <a class="el" href="struct_s_c_i_run_1_1_v_d_elem_index.html">DElem::index_type</a> i) const </td></tr>
<tr class="separator:a17da709840ba439292c656d7a24ec460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b2066278f303abea48eae34ed2dcb0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a03b2066278f303abea48eae34ed2dcb0">get_enodes</a> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">ENode::array_type</a> &amp;nodes, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> i) const </td></tr>
<tr class="separator:a03b2066278f303abea48eae34ed2dcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e96be6d52c08c5365a80193070bbadb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e96be6d52c08c5365a80193070bbadb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_enodes</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">ENode::array_type</a> &amp;nodes, <a class="el" href="struct_s_c_i_run_1_1_v_edge_index.html">Edge::index_type</a> i) const </td></tr>
<tr class="separator:a7e96be6d52c08c5365a80193070bbadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ceb33f28490e10473c8826ce8ee07ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ceb33f28490e10473c8826ce8ee07ec"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_enodes</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">ENode::array_type</a> &amp;nodes, <a class="el" href="struct_s_c_i_run_1_1_v_face_index.html">Face::index_type</a> i) const </td></tr>
<tr class="separator:a3ceb33f28490e10473c8826ce8ee07ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832382a55343d54b93cc1bd2d8ed95d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a832382a55343d54b93cc1bd2d8ed95d7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_enodes</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">ENode::array_type</a> &amp;nodes, <a class="el" href="struct_s_c_i_run_1_1_v_cell_index.html">Cell::index_type</a> i) const </td></tr>
<tr class="separator:a832382a55343d54b93cc1bd2d8ed95d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a804167edd255231ff58fee132d9802"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a804167edd255231ff58fee132d9802"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_enodes</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">ENode::array_type</a> &amp;nodes, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="separator:a3a804167edd255231ff58fee132d9802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4251ae98ba92ff5c2853c0e0d6fffdfc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4251ae98ba92ff5c2853c0e0d6fffdfc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_enodes</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">ENode::array_type</a> &amp;nodes, <a class="el" href="struct_s_c_i_run_1_1_v_d_elem_index.html">DElem::index_type</a> i) const </td></tr>
<tr class="separator:a4251ae98ba92ff5c2853c0e0d6fffdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99b719fe7551a8888d31cb77de80f3c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ad99b719fe7551a8888d31cb77de80f3c">get_edges</a> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Edge::array_type</a> &amp;edges, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> i) const </td></tr>
<tr class="separator:ad99b719fe7551a8888d31cb77de80f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf58b5013268cfc485edd36037fd557e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf58b5013268cfc485edd36037fd557e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_edges</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Edge::array_type</a> &amp;edges, <a class="el" href="struct_s_c_i_run_1_1_v_edge_index.html">Edge::index_type</a> i) const </td></tr>
<tr class="separator:adf58b5013268cfc485edd36037fd557e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59d8ca5ce4043aa846d16fc2815a058"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae59d8ca5ce4043aa846d16fc2815a058"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_edges</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Edge::array_type</a> &amp;edges, <a class="el" href="struct_s_c_i_run_1_1_v_face_index.html">Face::index_type</a> i) const </td></tr>
<tr class="separator:ae59d8ca5ce4043aa846d16fc2815a058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310cae18347f14d48b999bbfabb4dfba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a310cae18347f14d48b999bbfabb4dfba"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_edges</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Edge::array_type</a> &amp;edges, <a class="el" href="struct_s_c_i_run_1_1_v_cell_index.html">Cell::index_type</a> i) const </td></tr>
<tr class="separator:a310cae18347f14d48b999bbfabb4dfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3865e81ec134cd826040725133a3d665"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3865e81ec134cd826040725133a3d665"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_edges</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Edge::array_type</a> &amp;edges, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="separator:a3865e81ec134cd826040725133a3d665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6161c89087d12b74358f2a6359d0722c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6161c89087d12b74358f2a6359d0722c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_edges</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Edge::array_type</a> &amp;edges, <a class="el" href="struct_s_c_i_run_1_1_v_d_elem_index.html">DElem::index_type</a> i) const </td></tr>
<tr class="separator:a6161c89087d12b74358f2a6359d0722c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dc5176e9757e23ba9ec7e40994079f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab5dc5176e9757e23ba9ec7e40994079f">get_faces</a> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Face::array_type</a> &amp;faces, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> i) const </td></tr>
<tr class="separator:ab5dc5176e9757e23ba9ec7e40994079f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aaa920556494db3a739a15cfd55cac4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3aaa920556494db3a739a15cfd55cac4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_faces</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Face::array_type</a> &amp;faces, <a class="el" href="struct_s_c_i_run_1_1_v_edge_index.html">Edge::index_type</a> i) const </td></tr>
<tr class="separator:a3aaa920556494db3a739a15cfd55cac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b95e7c7b510966bf32f8f0c4036f12e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b95e7c7b510966bf32f8f0c4036f12e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_faces</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Face::array_type</a> &amp;faces, <a class="el" href="struct_s_c_i_run_1_1_v_face_index.html">Face::index_type</a> i) const </td></tr>
<tr class="separator:a2b95e7c7b510966bf32f8f0c4036f12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864e38533420293eec270c9578a7baba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a864e38533420293eec270c9578a7baba"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_faces</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Face::array_type</a> &amp;faces, <a class="el" href="struct_s_c_i_run_1_1_v_cell_index.html">Cell::index_type</a> i) const </td></tr>
<tr class="separator:a864e38533420293eec270c9578a7baba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39507eaaf33ae05dd27970084ffaf82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae39507eaaf33ae05dd27970084ffaf82"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_faces</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Face::array_type</a> &amp;faces, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="separator:ae39507eaaf33ae05dd27970084ffaf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866e69319825befe43839d85baf95aa3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a866e69319825befe43839d85baf95aa3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_faces</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Face::array_type</a> &amp;faces, <a class="el" href="struct_s_c_i_run_1_1_v_d_elem_index.html">DElem::index_type</a> i) const </td></tr>
<tr class="separator:a866e69319825befe43839d85baf95aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa505685d9726303f7f9f088262ca8893"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#aa505685d9726303f7f9f088262ca8893">get_cells</a> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Cell::array_type</a> &amp;cells, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> i) const </td></tr>
<tr class="separator:aa505685d9726303f7f9f088262ca8893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6cf6c0fc0a4f7f83e129c96bdbfab5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd6cf6c0fc0a4f7f83e129c96bdbfab5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_cells</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Cell::array_type</a> &amp;cells, <a class="el" href="struct_s_c_i_run_1_1_v_edge_index.html">Edge::index_type</a> i) const </td></tr>
<tr class="separator:acd6cf6c0fc0a4f7f83e129c96bdbfab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f71a6d916eb644b4795201535a7593b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f71a6d916eb644b4795201535a7593b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_cells</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Cell::array_type</a> &amp;cells, <a class="el" href="struct_s_c_i_run_1_1_v_face_index.html">Face::index_type</a> i) const </td></tr>
<tr class="separator:a2f71a6d916eb644b4795201535a7593b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a64394acb92ab32004a49a1c3eaa9e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a64394acb92ab32004a49a1c3eaa9e9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_cells</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Cell::array_type</a> &amp;cells, <a class="el" href="struct_s_c_i_run_1_1_v_cell_index.html">Cell::index_type</a> i) const </td></tr>
<tr class="separator:a4a64394acb92ab32004a49a1c3eaa9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64130c7181957cb78a8f96f55dfa844c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64130c7181957cb78a8f96f55dfa844c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_cells</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Cell::array_type</a> &amp;cells, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="separator:a64130c7181957cb78a8f96f55dfa844c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35838457985f8ebe5a55abe51209452a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35838457985f8ebe5a55abe51209452a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_cells</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Cell::array_type</a> &amp;cells, <a class="el" href="struct_s_c_i_run_1_1_v_d_elem_index.html">DElem::index_type</a> i) const </td></tr>
<tr class="separator:a35838457985f8ebe5a55abe51209452a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaeb677f2077719f429dbebb5e448581"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#acaeb677f2077719f429dbebb5e448581">get_elems</a> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Elem::array_type</a> &amp;elems, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> i) const </td></tr>
<tr class="separator:acaeb677f2077719f429dbebb5e448581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa382ad176643873dd346835658478105"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa382ad176643873dd346835658478105"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_elems</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Elem::array_type</a> &amp;elems, <a class="el" href="struct_s_c_i_run_1_1_v_edge_index.html">Edge::index_type</a> i) const </td></tr>
<tr class="separator:aa382ad176643873dd346835658478105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831328222eed8e579bb299af3b7cd1ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a831328222eed8e579bb299af3b7cd1ca"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_elems</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Elem::array_type</a> &amp;elems, <a class="el" href="struct_s_c_i_run_1_1_v_face_index.html">Face::index_type</a> i) const </td></tr>
<tr class="separator:a831328222eed8e579bb299af3b7cd1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca6b5ba7c8db0bc588581fa74ab3909"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ca6b5ba7c8db0bc588581fa74ab3909"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_elems</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Elem::array_type</a> &amp;elems, <a class="el" href="struct_s_c_i_run_1_1_v_cell_index.html">Cell::index_type</a> i) const </td></tr>
<tr class="separator:a4ca6b5ba7c8db0bc588581fa74ab3909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd54d31041a369c61f3c43b9becea3d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd54d31041a369c61f3c43b9becea3d0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_elems</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Elem::array_type</a> &amp;elems, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="separator:abd54d31041a369c61f3c43b9becea3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05a0f489ddfc978753bd63900c01b2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac05a0f489ddfc978753bd63900c01b2f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_elems</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Elem::array_type</a> &amp;elems, <a class="el" href="struct_s_c_i_run_1_1_v_d_elem_index.html">DElem::index_type</a> i) const </td></tr>
<tr class="separator:ac05a0f489ddfc978753bd63900c01b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f4e1b5430388b1ef318acce48d2372"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a57f4e1b5430388b1ef318acce48d2372">get_delems</a> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">DElem::array_type</a> &amp;delems, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> i) const </td></tr>
<tr class="separator:a57f4e1b5430388b1ef318acce48d2372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0436ef907aaeefbe7066979c5112cbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0436ef907aaeefbe7066979c5112cbf"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_delems</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">DElem::array_type</a> &amp;delems, <a class="el" href="struct_s_c_i_run_1_1_v_edge_index.html">Edge::index_type</a> i) const </td></tr>
<tr class="separator:ab0436ef907aaeefbe7066979c5112cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b82283ae15155e9d0b32d4cabe3c774"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b82283ae15155e9d0b32d4cabe3c774"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_delems</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">DElem::array_type</a> &amp;delems, <a class="el" href="struct_s_c_i_run_1_1_v_face_index.html">Face::index_type</a> i) const </td></tr>
<tr class="separator:a3b82283ae15155e9d0b32d4cabe3c774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c989817a418648f1a29854e3e57e5c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c989817a418648f1a29854e3e57e5c1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_delems</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">DElem::array_type</a> &amp;delems, <a class="el" href="struct_s_c_i_run_1_1_v_cell_index.html">Cell::index_type</a> i) const </td></tr>
<tr class="separator:a7c989817a418648f1a29854e3e57e5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f28cacf8e6072db48f28801d914df8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7f28cacf8e6072db48f28801d914df8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_delems</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">DElem::array_type</a> &amp;delems, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="separator:af7f28cacf8e6072db48f28801d914df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d763f84d23b0ccde87204d6f3faf0c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d763f84d23b0ccde87204d6f3faf0c8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_delems</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">DElem::array_type</a> &amp;delems, <a class="el" href="struct_s_c_i_run_1_1_v_d_elem_index.html">DElem::index_type</a> i) const </td></tr>
<tr class="separator:a7d763f84d23b0ccde87204d6f3faf0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fa5b0811e1916a08c4240e8b3bd7b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8fa5b0811e1916a08c4240e8b3bd7b0"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ac8fa5b0811e1916a08c4240e8b3bd7b0">get_elem</a> (<a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> &amp;elem, <a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;nodes) const </td></tr>
<tr class="memdesc:ac8fa5b0811e1916a08c4240e8b3bd7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the topology index from the vertex indices. <br/></td></tr>
<tr class="separator:ac8fa5b0811e1916a08c4240e8b3bd7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4796191b9ebc88576952f6665e5a9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a4796191b9ebc88576952f6665e5a9b"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_delem</b> (<a class="el" href="struct_s_c_i_run_1_1_v_d_elem_index.html">DElem::index_type</a> &amp;delem, <a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;nodes) const </td></tr>
<tr class="separator:a4a4796191b9ebc88576952f6665e5a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5629dd4f555653a8e2ff826714aa625e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5629dd4f555653a8e2ff826714aa625e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_cell</b> (<a class="el" href="struct_s_c_i_run_1_1_v_cell_index.html">Cell::index_type</a> &amp;cell, <a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;nodes) const </td></tr>
<tr class="separator:a5629dd4f555653a8e2ff826714aa625e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b059ab7cd84325a6a0eabdd386f7d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03b059ab7cd84325a6a0eabdd386f7d6"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_face</b> (<a class="el" href="struct_s_c_i_run_1_1_v_face_index.html">Face::index_type</a> &amp;face, <a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;nodes) const </td></tr>
<tr class="separator:a03b059ab7cd84325a6a0eabdd386f7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2175b4b60e7f82b723c05dec591256ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2175b4b60e7f82b723c05dec591256ae"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_edge</b> (<a class="el" href="struct_s_c_i_run_1_1_v_edge_index.html">Edge::index_type</a> &amp;edge, <a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;nodes) const </td></tr>
<tr class="separator:a2175b4b60e7f82b723c05dec591256ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91f196379dec626dcd3f45378098b3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae91f196379dec626dcd3f45378098b3a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ae91f196379dec626dcd3f45378098b3a">get_center</a> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> i) const </td></tr>
<tr class="memdesc:ae91f196379dec626dcd3f45378098b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the center of a certain mesh element. <br/></td></tr>
<tr class="separator:ae91f196379dec626dcd3f45378098b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5919b169abc3fe7d8c5fafa1730bf09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5919b169abc3fe7d8c5fafa1730bf09"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_center</b> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_e_node_index.html">ENode::index_type</a> i) const </td></tr>
<tr class="separator:aa5919b169abc3fe7d8c5fafa1730bf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42b2ec3b19d2bb29db15572fca0fa16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa42b2ec3b19d2bb29db15572fca0fa16"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_center</b> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_edge_index.html">Edge::index_type</a> i) const </td></tr>
<tr class="separator:aa42b2ec3b19d2bb29db15572fca0fa16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06987481e248ffb2279e8353ac84500e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06987481e248ffb2279e8353ac84500e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_center</b> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_face_index.html">Face::index_type</a> i) const </td></tr>
<tr class="separator:a06987481e248ffb2279e8353ac84500e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad299acad69ca9270c580f153b30f0665"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad299acad69ca9270c580f153b30f0665"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_center</b> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_cell_index.html">Cell::index_type</a> i) const </td></tr>
<tr class="separator:ad299acad69ca9270c580f153b30f0665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c40a79b3f3ca751c40f27a1606ec5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47c40a79b3f3ca751c40f27a1606ec5f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_center</b> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="separator:a47c40a79b3f3ca751c40f27a1606ec5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88521176d303c4df132fb723d3c465a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88521176d303c4df132fb723d3c465a8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_center</b> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_d_elem_index.html">DElem::index_type</a> i) const </td></tr>
<tr class="separator:a88521176d303c4df132fb723d3c465a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb27a6cca49a3052c9ba7c2b1ccd487d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb27a6cca49a3052c9ba7c2b1ccd487d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#acb27a6cca49a3052c9ba7c2b1ccd487d">get_centers</a> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> *points, <a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;array) const </td></tr>
<tr class="memdesc:acb27a6cca49a3052c9ba7c2b1ccd487d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the centers of a series of nodes. <br/></td></tr>
<tr class="separator:acb27a6cca49a3052c9ba7c2b1ccd487d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82941888c25ecdaef80b598063880320"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82941888c25ecdaef80b598063880320"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_centers</b> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> *points, <a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Elem::array_type</a> &amp;array) const </td></tr>
<tr class="separator:a82941888c25ecdaef80b598063880320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b38c6d318507015fc6d6edc475f0818"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a7b38c6d318507015fc6d6edc475f0818">get_centers</a> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a92441dd5102c545e55eaec85187b6562">points_type</a> &amp;points, <a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;array) const </td></tr>
<tr class="separator:a7b38c6d318507015fc6d6edc475f0818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d475d8881cb2c5d9f07c851d05c5b72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d475d8881cb2c5d9f07c851d05c5b72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_centers</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a92441dd5102c545e55eaec85187b6562">points_type</a> &amp;points, <a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Elem::array_type</a> &amp;array) const </td></tr>
<tr class="separator:a0d475d8881cb2c5d9f07c851d05c5b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405fbebef4b9c304fcafaa5a3b1f51d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a405fbebef4b9c304fcafaa5a3b1f51d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_all_node_centers</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a92441dd5102c545e55eaec85187b6562">points_type</a> &amp;points) const </td></tr>
<tr class="separator:a405fbebef4b9c304fcafaa5a3b1f51d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae91e58d70a209b4755cfd452eddac26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae91e58d70a209b4755cfd452eddac26"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_all_elem_centers</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a92441dd5102c545e55eaec85187b6562">points_type</a> &amp;points) const </td></tr>
<tr class="separator:aae91e58d70a209b4755cfd452eddac26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473c3d97886aa31ca068d1b0a429a3a4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a473c3d97886aa31ca068d1b0a429a3a4">get_size</a> (<a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a>) const </td></tr>
<tr class="separator:a473c3d97886aa31ca068d1b0a429a3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95448926ea6b8c0224e52b953b2eb55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad95448926ea6b8c0224e52b953b2eb55"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>get_size</b> (<a class="el" href="struct_s_c_i_run_1_1_v_e_node_index.html">ENode::index_type</a>) const </td></tr>
<tr class="separator:ad95448926ea6b8c0224e52b953b2eb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733ba32df2b2085d67041ab3e89045fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a733ba32df2b2085d67041ab3e89045fb"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a733ba32df2b2085d67041ab3e89045fb">get_size</a> (<a class="el" href="struct_s_c_i_run_1_1_v_edge_index.html">Edge::index_type</a> i) const </td></tr>
<tr class="memdesc:a733ba32df2b2085d67041ab3e89045fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the geometrical size of topological mesh components. <br/></td></tr>
<tr class="separator:a733ba32df2b2085d67041ab3e89045fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88e819e56d9300d3f32e1c3e225a57b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad88e819e56d9300d3f32e1c3e225a57b"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>get_size</b> (<a class="el" href="struct_s_c_i_run_1_1_v_face_index.html">Face::index_type</a> i) const </td></tr>
<tr class="separator:ad88e819e56d9300d3f32e1c3e225a57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e6ce1526fb39d5f870aa085d25e982"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59e6ce1526fb39d5f870aa085d25e982"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>get_size</b> (<a class="el" href="struct_s_c_i_run_1_1_v_cell_index.html">Cell::index_type</a> i) const </td></tr>
<tr class="separator:a59e6ce1526fb39d5f870aa085d25e982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b42c0cacb6059011ae6fba5c2cf8f66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b42c0cacb6059011ae6fba5c2cf8f66"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>get_size</b> (<a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="separator:a5b42c0cacb6059011ae6fba5c2cf8f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd561b8b4a74daedac5d2f5163d3858"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bd561b8b4a74daedac5d2f5163d3858"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>get_size</b> (<a class="el" href="struct_s_c_i_run_1_1_v_d_elem_index.html">DElem::index_type</a> i) const </td></tr>
<tr class="separator:a6bd561b8b4a74daedac5d2f5163d3858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417823d40d2cc250783a0fca744f1c6f"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a417823d40d2cc250783a0fca744f1c6f">get_size</a> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;array) const </td></tr>
<tr class="separator:a417823d40d2cc250783a0fca744f1c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc35b2afc08490f2948ea49e7a54fdc3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#abc35b2afc08490f2948ea49e7a54fdc3">get_length</a> (<a class="el" href="struct_s_c_i_run_1_1_v_edge_index.html">Edge::index_type</a> i) const </td></tr>
<tr class="separator:abc35b2afc08490f2948ea49e7a54fdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c75054db32b24908a4c1e72b365a93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50c75054db32b24908a4c1e72b365a93"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>get_area</b> (<a class="el" href="struct_s_c_i_run_1_1_v_face_index.html">Face::index_type</a> i) const </td></tr>
<tr class="separator:a50c75054db32b24908a4c1e72b365a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeaf5c2d2f6036a8c29a07ac24561869"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abeaf5c2d2f6036a8c29a07ac24561869"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>get_volume</b> (<a class="el" href="struct_s_c_i_run_1_1_v_cell_index.html">Cell::index_type</a> i) const </td></tr>
<tr class="separator:abeaf5c2d2f6036a8c29a07ac24561869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8866a7f1feeb24b38c8bf9a0eabee95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8866a7f1feeb24b38c8bf9a0eabee95"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>get_length</b> (<a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="separator:ab8866a7f1feeb24b38c8bf9a0eabee95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7e852c323ffc5b51dd14254067f3e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec7e852c323ffc5b51dd14254067f3e9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>get_area</b> (<a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="separator:aec7e852c323ffc5b51dd14254067f3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0e39afe9a747597da5a42d2f14a15d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b0e39afe9a747597da5a42d2f14a15d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>get_volume</b> (<a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="separator:a2b0e39afe9a747597da5a42d2f14a15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b09dd591f6296d4bf84093d8a516bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a67b09dd591f6296d4bf84093d8a516bb">get_interpolate_weights</a> (const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;p, <a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_elem_interpolate.html">ElemInterpolate</a> &amp;ei, int <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab98fe5591906f4908a1574429cb08879">basis_order</a>) const </td></tr>
<tr class="separator:a67b09dd591f6296d4bf84093d8a516bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e878ed9920e62364ca768323d568758"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e878ed9920e62364ca768323d568758"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_interpolate_weights</b> (const <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> elem, <a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_elem_interpolate.html">ElemInterpolate</a> &amp;ei, int <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab98fe5591906f4908a1574429cb08879">basis_order</a>) const </td></tr>
<tr class="separator:a6e878ed9920e62364ca768323d568758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6eeb23851662029b5bdee39e3ae080"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb6eeb23851662029b5bdee39e3ae080"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_minterpolate_weights</b> (const std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &gt; &amp;p, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a55178c395525bd261b30c878a0439981">MultiElemInterpolate</a> &amp;ei, int <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab98fe5591906f4908a1574429cb08879">basis_order</a>) const </td></tr>
<tr class="separator:adb6eeb23851662029b5bdee39e3ae080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1170ec25a34eff1a4c3f37dc58496d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef1170ec25a34eff1a4c3f37dc58496d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_minterpolate_weights</b> (const std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &gt; &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> elem, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a55178c395525bd261b30c878a0439981">MultiElemInterpolate</a> &amp;ei, int <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab98fe5591906f4908a1574429cb08879">basis_order</a>) const </td></tr>
<tr class="separator:aef1170ec25a34eff1a4c3f37dc58496d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01169c161ae5e7157f8066dc0c6d654"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad01169c161ae5e7157f8066dc0c6d654"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ad01169c161ae5e7157f8066dc0c6d654">get_gradient_weights</a> (const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;p, <a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_elem_gradient.html">ElemGradient</a> &amp;ei, int <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab98fe5591906f4908a1574429cb08879">basis_order</a>) const </td></tr>
<tr class="memdesc:ad01169c161ae5e7157f8066dc0c6d654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same functions but now for determining gradients. <br/></td></tr>
<tr class="separator:ad01169c161ae5e7157f8066dc0c6d654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbb79823aa7882f66c65b6d22314971"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cbb79823aa7882f66c65b6d22314971"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_gradient_weights</b> (const <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> elem, <a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_elem_gradient.html">ElemGradient</a> &amp;ei, int <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab98fe5591906f4908a1574429cb08879">basis_order</a>) const </td></tr>
<tr class="separator:a4cbb79823aa7882f66c65b6d22314971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66621d4710f8706722da378011857d36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66621d4710f8706722da378011857d36"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_mgradient_weights</b> (const std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &gt; &amp;p, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab35d232b06cdad0907657fc830879d2b">MultiElemGradient</a> &amp;ei, int <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab98fe5591906f4908a1574429cb08879">basis_order</a>) const </td></tr>
<tr class="separator:a66621d4710f8706722da378011857d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd98bc259068060130c91db1cc47fddf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd98bc259068060130c91db1cc47fddf"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_mgradient_weights</b> (const std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &gt; &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> elem, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab35d232b06cdad0907657fc830879d2b">MultiElemGradient</a> &amp;eg, int <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab98fe5591906f4908a1574429cb08879">basis_order</a>) const </td></tr>
<tr class="separator:acd98bc259068060130c91db1cc47fddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b15e3a7a6a65b15e8d2f1e029c7d794"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a1b15e3a7a6a65b15e8d2f1e029c7d794">get_weights</a> (const <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, std::vector&lt; double &gt; &amp;weights, int <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab98fe5591906f4908a1574429cb08879">basis_order</a>) const </td></tr>
<tr class="separator:a1b15e3a7a6a65b15e8d2f1e029c7d794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb76b716820326d46e39b4934e137e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#abfb76b716820326d46e39b4934e137e6">get_derivate_weights</a> (const <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, std::vector&lt; double &gt; &amp;weights, int <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab98fe5591906f4908a1574429cb08879">basis_order</a>) const </td></tr>
<tr class="separator:abfb76b716820326d46e39b4934e137e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8b71844f724b9c5a917cfb01c2312b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a6e8b71844f724b9c5a917cfb01c2312b">get_gaussian_scheme</a> (std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">VMesh::coords_type</a> &gt; &amp;coords, std::vector&lt; double &gt; &amp;weights, int order) const </td></tr>
<tr class="separator:a6e8b71844f724b9c5a917cfb01c2312b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9881646f84f974ae1588bf04248bd67e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9881646f84f974ae1588bf04248bd67e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_regular_scheme</b> (std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">VMesh::coords_type</a> &gt; &amp;coords, std::vector&lt; double &gt; &amp;weights, int order) const </td></tr>
<tr class="separator:a9881646f84f974ae1588bf04248bd67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7d05275282925ad4020b1577cce369"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#abc7d05275282925ad4020b1577cce369">locate</a> (<a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">VMesh::Node::index_type</a> &amp;i, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point) const </td></tr>
<tr class="separator:abc7d05275282925ad4020b1577cce369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad655714293ca7c543b6c5f580a6fd9bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad655714293ca7c543b6c5f580a6fd9bb"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>locate</b> (<a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">VMesh::Elem::index_type</a> &amp;i, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point) const </td></tr>
<tr class="separator:ad655714293ca7c543b6c5f580a6fd9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b94edbf886876ee404cd8a36083a2cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b94edbf886876ee404cd8a36083a2cc"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>locate</b> (<a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">VMesh::Elem::index_type</a> &amp;i, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">VMesh::coords_type</a> &amp;coords, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point) const </td></tr>
<tr class="separator:a7b94edbf886876ee404cd8a36083a2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7e0189fb8abcbc2f09dc3089de9ca1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a4f7e0189fb8abcbc2f09dc3089de9ca1">mlocate</a> (std::vector&lt; <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> &gt; &amp;i, const std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &gt; &amp;point) const </td></tr>
<tr class="separator:a4f7e0189fb8abcbc2f09dc3089de9ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefb248d3c0347c36161ae3275b09763"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adefb248d3c0347c36161ae3275b09763"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>mlocate</b> (std::vector&lt; <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> &gt; &amp;i, const std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &gt; &amp;point) const </td></tr>
<tr class="separator:adefb248d3c0347c36161ae3275b09763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9271421fd303bc510e1a8f7cde61d1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a0e9271421fd303bc510e1a8f7cde61d1">locate</a> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">VMesh::Elem::array_type</a> &amp;a, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_b_box.html">Core::Geometry::BBox</a> &amp;bbox) const </td></tr>
<tr class="separator:a0e9271421fd303bc510e1a8f7cde61d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba39e007efde392700db45ffd236cd4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a5ba39e007efde392700db45ffd236cd4">find_closest_node</a> (double &amp;dist, <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;result, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">VMesh::Node::index_type</a> &amp;i, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point) const </td></tr>
<tr class="memdesc:a5ba39e007efde392700db45ffd236cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the closest point on a surface or a curve.  <a href="#a5ba39e007efde392700db45ffd236cd4">More...</a><br/></td></tr>
<tr class="separator:a5ba39e007efde392700db45ffd236cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4392ad70c719e8b36324d8586fc6ed9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ae4392ad70c719e8b36324d8586fc6ed9">find_closest_node</a> (double &amp;dist, <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;result, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">VMesh::Node::index_type</a> &amp;i, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, double maxdist) const </td></tr>
<tr class="separator:ae4392ad70c719e8b36324d8586fc6ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8476baeaef322021ef98ebfb43fd7f8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8476baeaef322021ef98ebfb43fd7f8e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a8476baeaef322021ef98ebfb43fd7f8e">find_closest_node</a> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;result, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">VMesh::Node::index_type</a> &amp;i, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, double maxdist)</td></tr>
<tr class="memdesc:a8476baeaef322021ef98ebfb43fd7f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified version that does not return the distance. <br/></td></tr>
<tr class="separator:a8476baeaef322021ef98ebfb43fd7f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cef2fb7b2481167bcbda1a108b68e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15cef2fb7b2481167bcbda1a108b68e9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a15cef2fb7b2481167bcbda1a108b68e9">find_closest_node</a> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;result, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">VMesh::Node::index_type</a> &amp;i, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point)</td></tr>
<tr class="memdesc:a15cef2fb7b2481167bcbda1a108b68e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified version that does not return the distance. <br/></td></tr>
<tr class="separator:a15cef2fb7b2481167bcbda1a108b68e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9b3aa10bb9570564bd273ac90abb67"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#aea9b3aa10bb9570564bd273ac90abb67">find_closest_nodes</a> (std::vector&lt; <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">VMesh::Node::index_type</a> &gt; &amp;nodes, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;p, double maxdist) const </td></tr>
<tr class="separator:aea9b3aa10bb9570564bd273ac90abb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33595f4f3f974be3f0d3eef2139f8942"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33595f4f3f974be3f0d3eef2139f8942"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>find_closest_nodes</b> (std::vector&lt; double &gt; &amp;distances, std::vector&lt; <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">VMesh::Node::index_type</a> &gt; &amp;nodes, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;p, double maxdist) const </td></tr>
<tr class="separator:a33595f4f3f974be3f0d3eef2139f8942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcf8798bfa3778f8356e23b3bfe55de"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#acbcf8798bfa3778f8356e23b3bfe55de">find_closest_elem</a> (double &amp;dist, <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;result, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">VMesh::coords_type</a> &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">VMesh::Elem::index_type</a> &amp;i, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point) const </td></tr>
<tr class="separator:acbcf8798bfa3778f8356e23b3bfe55de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276b1f015861c0d1f2772b37e4f0ac1e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a276b1f015861c0d1f2772b37e4f0ac1e">find_closest_elem</a> (double &amp;dist, <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;result, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">VMesh::coords_type</a> &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">VMesh::Elem::index_type</a> &amp;i, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, double maxdist) const </td></tr>
<tr class="separator:a276b1f015861c0d1f2772b37e4f0ac1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515edcb854a9634b871331ab07ffdf67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a515edcb854a9634b871331ab07ffdf67"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a515edcb854a9634b871331ab07ffdf67">find_closest_elem</a> (double &amp;dist, <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;result, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">VMesh::Elem::index_type</a> &amp;i, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point) const </td></tr>
<tr class="memdesc:a515edcb854a9634b871331ab07ffdf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified version that does not return the local coordinates. <br/></td></tr>
<tr class="separator:a515edcb854a9634b871331ab07ffdf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa544582e692b62ac39fd6f3714642a34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa544582e692b62ac39fd6f3714642a34"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>find_closest_elem</b> (double &amp;dist, <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;result, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">VMesh::Elem::index_type</a> &amp;i, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, double maxdist) const </td></tr>
<tr class="separator:aa544582e692b62ac39fd6f3714642a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7980645d7e8bc1b8ac250d6157382e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7980645d7e8bc1b8ac250d6157382e6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab7980645d7e8bc1b8ac250d6157382e6">find_closest_elem</a> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;result, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">VMesh::Elem::index_type</a> &amp;i, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point) const </td></tr>
<tr class="memdesc:ab7980645d7e8bc1b8ac250d6157382e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Even more simplified version. <br/></td></tr>
<tr class="separator:ab7980645d7e8bc1b8ac250d6157382e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5b67cc6f3dec9ca0eb12e6392028b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e5b67cc6f3dec9ca0eb12e6392028b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a8e5b67cc6f3dec9ca0eb12e6392028b6">find_closest_elem</a> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">VMesh::coords_type</a> &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">VMesh::Elem::index_type</a> &amp;i, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point) const </td></tr>
<tr class="memdesc:a8e5b67cc6f3dec9ca0eb12e6392028b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Another simplified version. <br/></td></tr>
<tr class="separator:a8e5b67cc6f3dec9ca0eb12e6392028b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581153a86a8d175204430e668a7cab99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a581153a86a8d175204430e668a7cab99"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>find_closest_elems</b> (double &amp;dist, <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;result, <a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">VMesh::Elem::array_type</a> &amp;i, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point) const </td></tr>
<tr class="separator:a581153a86a8d175204430e668a7cab99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece60a19dd30090c4d2be5e2b8c6223d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aece60a19dd30090c4d2be5e2b8c6223d"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#aece60a19dd30090c4d2be5e2b8c6223d">get_coords</a> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="memdesc:aece60a19dd30090c4d2be5e2b8c6223d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the coordinates of a point in a certain element. <br/></td></tr>
<tr class="separator:aece60a19dd30090c4d2be5e2b8c6223d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318ab997985c2979775fb9364dfe0ad4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a318ab997985c2979775fb9364dfe0ad4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a318ab997985c2979775fb9364dfe0ad4">interpolate</a> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;p, const <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="memdesc:a318ab997985c2979775fb9364dfe0ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate from local coordinates to global coordinates. <br/></td></tr>
<tr class="separator:a318ab997985c2979775fb9364dfe0ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2bc1eadd1bfa00f42674823a5c23b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a2bc1eadd1bfa00f42674823a5c23b3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a2a2bc1eadd1bfa00f42674823a5c23b3">minterpolate</a> (std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &gt; &amp;p, const std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &gt; &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="memdesc:a2a2bc1eadd1bfa00f42674823a5c23b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiple interpolations from local coordinates to global coordinates. <br/></td></tr>
<tr class="separator:a2a2bc1eadd1bfa00f42674823a5c23b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c208d1928a3912b945ac06b40ddf6ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c208d1928a3912b945ac06b40ddf6ed"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a3c208d1928a3912b945ac06b40ddf6ed">derivate</a> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a6035940e63cb533cb69e5bee63cd53e5">dpoints_type</a> &amp;p, const <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="memdesc:a3c208d1928a3912b945ac06b40ddf6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate from local coordinates to a derivative in local coordinates. <br/></td></tr>
<tr class="separator:a3c208d1928a3912b945ac06b40ddf6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a7a6c384cd1f52f37f601e8a5b503a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a37a7a6c384cd1f52f37f601e8a5b503a">get_normal</a> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_vector.html">Core::Geometry::Vector</a> &amp;result, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> eidx, <a class="el" href="struct_s_c_i_run_1_1_v_d_elem_index.html">DElem::index_type</a> fidx) const </td></tr>
<tr class="separator:a37a7a6c384cd1f52f37f601e8a5b503a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2542f705c08f9c11c1306d24329dc776"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2542f705c08f9c11c1306d24329dc776"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a2542f705c08f9c11c1306d24329dc776">get_normal</a> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_vector.html">Core::Geometry::Vector</a> &amp;result, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> eidx) const </td></tr>
<tr class="memdesc:a2542f705c08f9c11c1306d24329dc776"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the surface version. <br/></td></tr>
<tr class="separator:a2542f705c08f9c11c1306d24329dc776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7964a77fc8d131f552c41fecf140979c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7964a77fc8d131f552c41fecf140979c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a7964a77fc8d131f552c41fecf140979c">get_normals</a> (std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_vector.html">Core::Geometry::Vector</a> &gt; &amp;result, std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &gt; &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> eidx) const </td></tr>
<tr class="memdesc:a7964a77fc8d131f552c41fecf140979c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiple normals short cut. <br/></td></tr>
<tr class="separator:a7964a77fc8d131f552c41fecf140979c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f2d53503f5bd473bfc6549f61703c5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a22f2d53503f5bd473bfc6549f61703c5">get_random_point</a> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;p, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i, <a class="el" href="class_s_c_i_run_1_1_field_r_n_g.html">FieldRNG</a> &amp;rng) const </td></tr>
<tr class="memdesc:a22f2d53503f5bd473bfc6549f61703c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the location of a random point inside the mesh.  <a href="#a22f2d53503f5bd473bfc6549f61703c5">More...</a><br/></td></tr>
<tr class="separator:a22f2d53503f5bd473bfc6549f61703c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cda64c3da7ff79c384504e704f758c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a7cda64c3da7ff79c384504e704f758c3">get_point</a> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> i) const </td></tr>
<tr class="separator:a7cda64c3da7ff79c384504e704f758c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aee331d26cec17992abecd01c5aed5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3aee331d26cec17992abecd01c5aed5d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_point</b> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_e_node_index.html">ENode::index_type</a> i) const </td></tr>
<tr class="separator:a3aee331d26cec17992abecd01c5aed5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3d97d3071cf40839af645e10fb0f13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e3d97d3071cf40839af645e10fb0f13"></a>
<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_point</b> (<a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> i) const </td></tr>
<tr class="separator:a2e3d97d3071cf40839af645e10fb0f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66764226df2abd11a55da9fafea18cea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66764226df2abd11a55da9fafea18cea"></a>
<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_point</b> (<a class="el" href="struct_s_c_i_run_1_1_v_e_node_index.html">ENode::index_type</a> i) const </td></tr>
<tr class="separator:a66764226df2abd11a55da9fafea18cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf10f8fce7a21d8dd922888775b89e33"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#abf10f8fce7a21d8dd922888775b89e33">set_point</a> (const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> i)</td></tr>
<tr class="separator:abf10f8fce7a21d8dd922888775b89e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fba9e8698ea9fdc084bab83466a19b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07fba9e8698ea9fdc084bab83466a19b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_point</b> (const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_e_node_index.html">ENode::index_type</a> i)</td></tr>
<tr class="separator:a07fba9e8698ea9fdc084bab83466a19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b675835ed87f5271dae318c49013b8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#af4b675835ed87f5271dae318c49013b8">get_points_pointer</a> () const </td></tr>
<tr class="separator:af4b675835ed87f5271dae318c49013b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec36714404fa1f914a95b97acb2465fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec36714404fa1f914a95b97acb2465fa"></a>
virtual <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">VMesh::index_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_elems_pointer</b> () const </td></tr>
<tr class="separator:aec36714404fa1f914a95b97acb2465fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bffa0b267b92834615f8c5e3e88f2c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a1bffa0b267b92834615f8c5e3e88f2c7">copy_nodes</a> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html">VMesh</a> *imesh, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> i, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> o, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::size_type</a> <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab96ee649dad57ef154e54b22c282511a">size</a>)</td></tr>
<tr class="separator:a1bffa0b267b92834615f8c5e3e88f2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373c22fe3c0695ddaabd6e1302213b8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a373c22fe3c0695ddaabd6e1302213b8b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_nodes</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html">VMesh</a> *imesh)</td></tr>
<tr class="separator:a373c22fe3c0695ddaabd6e1302213b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58dcbf7c4517a02322861bb5bebe97d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58dcbf7c4517a02322861bb5bebe97d3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_elems</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html">VMesh</a> *imesh, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> o, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::size_type</a> <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab96ee649dad57ef154e54b22c282511a">size</a>, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::size_type</a> offset)</td></tr>
<tr class="separator:a58dcbf7c4517a02322861bb5bebe97d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab959a45b7f83edf06acf684cc8237332"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab959a45b7f83edf06acf684cc8237332"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_elems</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html">VMesh</a> *imesh)</td></tr>
<tr class="separator:ab959a45b7f83edf06acf684cc8237332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a63db6f39f31a546defa5ffcb0d2fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a59a63db6f39f31a546defa5ffcb0d2fc">node_reserve</a> (size_t <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab96ee649dad57ef154e54b22c282511a">size</a>)</td></tr>
<tr class="separator:a59a63db6f39f31a546defa5ffcb0d2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cda96106e5c4d5b59b711c03e4674f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cda96106e5c4d5b59b711c03e4674f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve_nodes</b> (size_t <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab96ee649dad57ef154e54b22c282511a">size</a>)</td></tr>
<tr class="separator:a6cda96106e5c4d5b59b711c03e4674f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25227f65c034b9f6f61c07e51d8e71af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25227f65c034b9f6f61c07e51d8e71af"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a25227f65c034b9f6f61c07e51d8e71af">elem_reserve</a> (size_t <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab96ee649dad57ef154e54b22c282511a">size</a>)</td></tr>
<tr class="memdesc:a25227f65c034b9f6f61c07e51d8e71af"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserve memory by specifying the number of elements that is expected <br/></td></tr>
<tr class="separator:a25227f65c034b9f6f61c07e51d8e71af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30814d174708bc524ecb16ffb3153548"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30814d174708bc524ecb16ffb3153548"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve_elems</b> (size_t <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab96ee649dad57ef154e54b22c282511a">size</a>)</td></tr>
<tr class="separator:a30814d174708bc524ecb16ffb3153548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec248c20592d8929b517ca7d99fedb9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a3ec248c20592d8929b517ca7d99fedb9">resize_nodes</a> (size_t <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab96ee649dad57ef154e54b22c282511a">size</a>)</td></tr>
<tr class="separator:a3ec248c20592d8929b517ca7d99fedb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb148e19385faabbbc96b2cd21f31e6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb148e19385faabbbc96b2cd21f31e6d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>resize_elems</b> (size_t <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab96ee649dad57ef154e54b22c282511a">size</a>)</td></tr>
<tr class="separator:adb148e19385faabbbc96b2cd21f31e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac553b74908a926eb6c65a97b9152b75e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac553b74908a926eb6c65a97b9152b75e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resize_points</b> (size_t <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab96ee649dad57ef154e54b22c282511a">size</a>)</td></tr>
<tr class="separator:ac553b74908a926eb6c65a97b9152b75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0b911618f1de04252e0742718be92b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c0b911618f1de04252e0742718be92b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a8c0b911618f1de04252e0742718be92b">add_node</a> (const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> &amp;i)</td></tr>
<tr class="memdesc:a8c0b911618f1de04252e0742718be92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to a mesh. <br/></td></tr>
<tr class="separator:a8c0b911618f1de04252e0742718be92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ae9de5c3db2cdd34bb6d8b2ebde1b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09ae9de5c3db2cdd34bb6d8b2ebde1b2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>add_enode</b> (const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_e_node_index.html">ENode::index_type</a> &amp;i)</td></tr>
<tr class="separator:a09ae9de5c3db2cdd34bb6d8b2ebde1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445dd0a29226471e4118357997da3015"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a445dd0a29226471e4118357997da3015"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a445dd0a29226471e4118357997da3015">set_node</a> (const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> i)</td></tr>
<tr class="memdesc:a445dd0a29226471e4118357997da3015"><td class="mdescLeft">&#160;</td><td class="mdescRight">alternative calls <br/></td></tr>
<tr class="separator:a445dd0a29226471e4118357997da3015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478b3851d1c1b3a20acc3f2797cde784"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a478b3851d1c1b3a20acc3f2797cde784"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_enode</b> (const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_e_node_index.html">ENode::index_type</a> i)</td></tr>
<tr class="separator:a478b3851d1c1b3a20acc3f2797cde784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f95d7692a7c05f69c2b5de00bf1da2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76f95d7692a7c05f69c2b5de00bf1da2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_nodes</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;array, <a class="el" href="struct_s_c_i_run_1_1_v_edge_index.html">Edge::index_type</a> idx)</td></tr>
<tr class="separator:a76f95d7692a7c05f69c2b5de00bf1da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b476749d8b26fb140f651fc8c798693"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b476749d8b26fb140f651fc8c798693"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_nodes</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;array, <a class="el" href="struct_s_c_i_run_1_1_v_face_index.html">Face::index_type</a> idx)</td></tr>
<tr class="separator:a6b476749d8b26fb140f651fc8c798693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca64676d9d2e2ee21b1edeafc136682"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ca64676d9d2e2ee21b1edeafc136682"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_nodes</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;array, <a class="el" href="struct_s_c_i_run_1_1_v_cell_index.html">Cell::index_type</a> idx)</td></tr>
<tr class="separator:a4ca64676d9d2e2ee21b1edeafc136682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e27d7ccae9a942aed7590962ef8e68c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e27d7ccae9a942aed7590962ef8e68c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_nodes</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;array, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> idx)</td></tr>
<tr class="separator:a9e27d7ccae9a942aed7590962ef8e68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa158e25a26a802506334219c9b8aed4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa158e25a26a802506334219c9b8aed4"></a>
<a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>add_node</b> (const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point)</td></tr>
<tr class="separator:aaa158e25a26a802506334219c9b8aed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74dffd9b770106e1864fb3183e522a67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74dffd9b770106e1864fb3183e522a67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_node</b> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> i)</td></tr>
<tr class="separator:a74dffd9b770106e1864fb3183e522a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9940518a0f4b327380ea90000daad063"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9940518a0f4b327380ea90000daad063"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_enode</b> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point, <a class="el" href="struct_s_c_i_run_1_1_v_e_node_index.html">ENode::index_type</a> i)</td></tr>
<tr class="separator:a9940518a0f4b327380ea90000daad063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccf16e86e122c4ce128814b8ccc365e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">VMesh::Node::index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a6ccf16e86e122c4ce128814b8ccc365e">add_point</a> (const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point)</td></tr>
<tr class="separator:a6ccf16e86e122c4ce128814b8ccc365e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aae0fa8e8a4d40380ba0290d71c4a6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aae0fa8e8a4d40380ba0290d71c4a6b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a7aae0fa8e8a4d40380ba0290d71c4a6b">add_elem</a> (const <a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;nodes, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> &amp;i)</td></tr>
<tr class="memdesc:a7aae0fa8e8a4d40380ba0290d71c4a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an element to a mesh. <br/></td></tr>
<tr class="separator:a7aae0fa8e8a4d40380ba0290d71c4a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0dc3adaa7e93a1b6fd9ae778f95ec8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a0dc3adaa7e93a1b6fd9ae778f95ec8"></a>
<a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">VMesh::Elem::index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a3a0dc3adaa7e93a1b6fd9ae778f95ec8">add_elem</a> (const <a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> nodes)</td></tr>
<tr class="memdesc:a3a0dc3adaa7e93a1b6fd9ae778f95ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative calls for add_elem. <br/></td></tr>
<tr class="separator:a3a0dc3adaa7e93a1b6fd9ae778f95ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff220a504f3f6b9395312c5aa2c92c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ff220a504f3f6b9395312c5aa2c92c5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a2ff220a504f3f6b9395312c5aa2c92c5">insert_node_into_elem</a> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Elem::array_type</a> &amp;newelems, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> &amp;newnode, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> elem, <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;point)</td></tr>
<tr class="memdesc:a2ff220a504f3f6b9395312c5aa2c92c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently only available for tetrahedra, triangles and curves. <br/></td></tr>
<tr class="separator:a2ff220a504f3f6b9395312c5aa2c92c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8858a56f43648f0caacfed5487c609c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8858a56f43648f0caacfed5487c609c4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a8858a56f43648f0caacfed5487c609c4">get_neighbor</a> (<a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> &amp;neighbor, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> from, <a class="el" href="struct_s_c_i_run_1_1_v_d_elem_index.html">DElem::index_type</a> delem) const </td></tr>
<tr class="memdesc:a8858a56f43648f0caacfed5487c609c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the neighbors of a node or an element. <br/></td></tr>
<tr class="separator:a8858a56f43648f0caacfed5487c609c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2978a0106a9457cb8abcfa6c1380c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc2978a0106a9457cb8abcfa6c1380c9"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_neighbors</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Elem::array_type</a> &amp;elems, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i, <a class="el" href="struct_s_c_i_run_1_1_v_d_elem_index.html">DElem::index_type</a> delem) const </td></tr>
<tr class="separator:acc2978a0106a9457cb8abcfa6c1380c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99926475d13c7641f1d84538e7c7c931"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99926475d13c7641f1d84538e7c7c931"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_neighbors</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Elem::array_type</a> &amp;elems, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> i) const </td></tr>
<tr class="separator:a99926475d13c7641f1d84538e7c7c931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df37ca45a59bde005e7ece0d99d6838"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3df37ca45a59bde005e7ece0d99d6838"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_neighbors</b> (<a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;nodes, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> i) const </td></tr>
<tr class="separator:a3df37ca45a59bde005e7ece0d99d6838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf6895589a3716bbf82e393c6581ab9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdf6895589a3716bbf82e393c6581ab9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#abdf6895589a3716bbf82e393c6581ab9">pwl_approx_edge</a> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ad682e81b4b76f2fb01404e31f92e3bb2">coords_array_type</a> &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> ci, unsigned int which_edge, unsigned int div_per_unit) const </td></tr>
<tr class="memdesc:abdf6895589a3716bbf82e393c6581ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw non linear elements. <br/></td></tr>
<tr class="separator:abdf6895589a3716bbf82e393c6581ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363f1d4ee3e433c9c2ce3fd0d3b2a919"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a363f1d4ee3e433c9c2ce3fd0d3b2a919"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>pwl_approx_face</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a463c02f0bc5c9bfc08a2147c824b509a">coords_array2_type</a> &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> ci, unsigned int which_face, unsigned int div_per_unit) const </td></tr>
<tr class="separator:a363f1d4ee3e433c9c2ce3fd0d3b2a919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b768c41db75a3433f05412d4a4ae35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49b768c41db75a3433f05412d4a4ae35"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a49b768c41db75a3433f05412d4a4ae35">get_normal</a> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_vector.html">Core::Geometry::Vector</a> &amp;<a class="el" href="structnorm.html">norm</a>, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> i) const </td></tr>
<tr class="memdesc:a49b768c41db75a3433f05412d4a4ae35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node normals, needed for visualization. <br/></td></tr>
<tr class="separator:a49b768c41db75a3433f05412d4a4ae35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4904774928ed3dc1b64fba281b5e9d66"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a4904774928ed3dc1b64fba281b5e9d66">get_dimensions</a> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a8b813c7746a5777053cad48af766af15">dimension_type</a> &amp;dim)</td></tr>
<tr class="separator:a4904774928ed3dc1b64fba281b5e9d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae539400f6181ad2985ef8f6fc1abd7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae539400f6181ad2985ef8f6fc1abd7f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_elem_dimensions</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a8b813c7746a5777053cad48af766af15">dimension_type</a> &amp;dim)</td></tr>
<tr class="separator:aae539400f6181ad2985ef8f6fc1abd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe14e798576c9a5fa3aa026c2934f3ee"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#afe14e798576c9a5fa3aa026c2934f3ee">det_jacobian</a> (const <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> idx) const </td></tr>
<tr class="separator:afe14e798576c9a5fa3aa026c2934f3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa745269fbdfa92a940668c0d7cc89912"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#aa745269fbdfa92a940668c0d7cc89912">jacobian</a> (const <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> idx, double *J) const </td></tr>
<tr class="separator:aa745269fbdfa92a940668c0d7cc89912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1444093f1f7b4862b5aed558133fd3af"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a1444093f1f7b4862b5aed558133fd3af">inverse_jacobian</a> (const <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> idx, double *Ji) const </td></tr>
<tr class="separator:a1444093f1f7b4862b5aed558133fd3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33196f0d2e9c2caa9042171e23d8793"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ae33196f0d2e9c2caa9042171e23d8793">scaled_jacobian_metric</a> (const <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> idx) const </td></tr>
<tr class="memdesc:ae33196f0d2e9c2caa9042171e23d8793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element Quality metrics:  <a href="#ae33196f0d2e9c2caa9042171e23d8793">More...</a><br/></td></tr>
<tr class="separator:ae33196f0d2e9c2caa9042171e23d8793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613768e1cfdbd5c19beef18481cff9dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a613768e1cfdbd5c19beef18481cff9dc"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a613768e1cfdbd5c19beef18481cff9dc">jacobian_metric</a> (const <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> idx) const </td></tr>
<tr class="memdesc:a613768e1cfdbd5c19beef18481cff9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobian of local to global transformation. <br/></td></tr>
<tr class="separator:a613768e1cfdbd5c19beef18481cff9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846cbad76329215161b517fa08136f90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a846cbad76329215161b517fa08136f90"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a846cbad76329215161b517fa08136f90">volume_metric</a> (const <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> idx) const </td></tr>
<tr class="memdesc:a846cbad76329215161b517fa08136f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume of an element. <br/></td></tr>
<tr class="separator:a846cbad76329215161b517fa08136f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856ae7d441db533982bdae8c17593e05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a856ae7d441db533982bdae8c17593e05"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a856ae7d441db533982bdae8c17593e05">inscribed_circumscribed_radius_metric</a> (<a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> idx) const </td></tr>
<tr class="memdesc:a856ae7d441db533982bdae8c17593e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaled inscribed to circumscribed ratio. <br/></td></tr>
<tr class="separator:a856ae7d441db533982bdae8c17593e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d8979ac454b266d0cb67824a065374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab0d8979ac454b266d0cb67824a065374">get_constant_weights</a> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;, std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="separator:ab0d8979ac454b266d0cb67824a065374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faa4154e9a86f7f0177778f251cf580"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9faa4154e9a86f7f0177778f251cf580"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_linear_weights</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="separator:a9faa4154e9a86f7f0177778f251cf580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa25e70664248657756a8be4c39d8ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaa25e70664248657756a8be4c39d8ec"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_quadratic_weights</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="separator:aeaa25e70664248657756a8be4c39d8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca02f8c311ce1e5dce3e095a0bd58a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeca02f8c311ce1e5dce3e095a0bd58a5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_cubic_weights</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="separator:aeca02f8c311ce1e5dce3e095a0bd58a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497b3b516adb76609a872c87e00ef43a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a497b3b516adb76609a872c87e00ef43a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a497b3b516adb76609a872c87e00ef43a">get_constant_derivate_weights</a> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;, std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="memdesc:a497b3b516adb76609a872c87e00ef43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">These four are for computating gradients. <br/></td></tr>
<tr class="separator:a497b3b516adb76609a872c87e00ef43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b66418f97e6c0eabdbdef9fbadb7c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12b66418f97e6c0eabdbdef9fbadb7c6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_linear_derivate_weights</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="separator:a12b66418f97e6c0eabdbdef9fbadb7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7368179f327383d58d643b6a2061d35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7368179f327383d58d643b6a2061d35"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_quadratic_derivate_weights</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="separator:af7368179f327383d58d643b6a2061d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7718cf1f043cc1b6835abdfcc6a5b83a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7718cf1f043cc1b6835abdfcc6a5b83a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_cubic_derivate_weights</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords, std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="separator:a7718cf1f043cc1b6835abdfcc6a5b83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed83c41adf9165d759f35608ead22b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaed83c41adf9165d759f35608ead22b4"></a>
virtual <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_b_box.html">Core::Geometry::BBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#aaed83c41adf9165d759f35608ead22b4">get_bounding_box</a> () const </td></tr>
<tr class="memdesc:aaed83c41adf9165d759f35608ead22b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rerouting of some of the virtual mesh function calls. <br/></td></tr>
<tr class="separator:aaed83c41adf9165d759f35608ead22b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd7ece5dfecbef33f69c70277d8956c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dd7ece5dfecbef33f69c70277d8956c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a0dd7ece5dfecbef33f69c70277d8956c">synchronize</a> (unsigned int sync)</td></tr>
<tr class="memdesc:a0dd7ece5dfecbef33f69c70277d8956c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This call is for synchronizing tables of precomputed elements. <br/></td></tr>
<tr class="separator:a0dd7ece5dfecbef33f69c70277d8956c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a68a9a176a45b714d7baadc008f77c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a68a9a176a45b714d7baadc008f77c1"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>unsynchronize</b> (unsigned int sync)</td></tr>
<tr class="separator:a1a68a9a176a45b714d7baadc008f77c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d09042e774f1bacb82ef2c48f7adcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55d09042e774f1bacb82ef2c48f7adcb"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>clear_synchronization</b> ()</td></tr>
<tr class="separator:a55d09042e774f1bacb82ef2c48f7adcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ae9297584c51dc98c96ad939cbeb63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22ae9297584c51dc98c96ad939cbeb63"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>transform</b> (const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_transform.html">Core::Geometry::Transform</a> &amp;t)</td></tr>
<tr class="separator:a22ae9297584c51dc98c96ad939cbeb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587368f0f081b393b8f93522cb7e1519"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a587368f0f081b393b8f93522cb7e1519"></a>
virtual <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_transform.html">Core::Geometry::Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a587368f0f081b393b8f93522cb7e1519">get_transform</a> () const </td></tr>
<tr class="memdesc:a587368f0f081b393b8f93522cb7e1519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transform from a regular field. <br/></td></tr>
<tr class="separator:a587368f0f081b393b8f93522cb7e1519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b6a22812be6fbaa5fc1ab6468c0247"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20b6a22812be6fbaa5fc1ab6468c0247"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a20b6a22812be6fbaa5fc1ab6468c0247">set_transform</a> (const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_transform.html">Core::Geometry::Transform</a> &amp;t)</td></tr>
<tr class="memdesc:a20b6a22812be6fbaa5fc1ab6468c0247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the transform of a regular field. <br/></td></tr>
<tr class="separator:a20b6a22812be6fbaa5fc1ab6468c0247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b633aa68a227a7f10b12ff67cfab8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32b633aa68a227a7f10b12ff67cfab8b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_canonical_transform</b> (<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_transform.html">Core::Geometry::Transform</a> &amp;t)</td></tr>
<tr class="separator:a32b633aa68a227a7f10b12ff67cfab8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab381b7fb5ac6ffff649208012c590e4f"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab381b7fb5ac6ffff649208012c590e4f">get_epsilon</a> () const </td></tr>
<tr class="separator:ab381b7fb5ac6ffff649208012c590e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104a582e164d71504f6476409b84e18f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a104a582e164d71504f6476409b84e18f"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a104a582e164d71504f6476409b84e18f">is_pointcloudmesh</a> ()</td></tr>
<tr class="memdesc:a104a582e164d71504f6476409b84e18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the type of mesh <br/></td></tr>
<tr class="separator:a104a582e164d71504f6476409b84e18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab04ee58db774b2102aab8da9017ec48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab04ee58db774b2102aab8da9017ec48"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_curvemesh</b> ()</td></tr>
<tr class="separator:aab04ee58db774b2102aab8da9017ec48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf707a59b4e38d4765e088fdacf105bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf707a59b4e38d4765e088fdacf105bc"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_scanlinemesh</b> ()</td></tr>
<tr class="separator:adf707a59b4e38d4765e088fdacf105bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1af51e9e39a4d227bf67fef743c442"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad1af51e9e39a4d227bf67fef743c442"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_structcurvemesh</b> ()</td></tr>
<tr class="separator:aad1af51e9e39a4d227bf67fef743c442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29759529154c22778336649064c8738"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae29759529154c22778336649064c8738"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_trisurfmesh</b> ()</td></tr>
<tr class="separator:ae29759529154c22778336649064c8738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadec01d27ddcd72adaa5313bd86b1211"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadec01d27ddcd72adaa5313bd86b1211"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_quadsurfmesh</b> ()</td></tr>
<tr class="separator:aadec01d27ddcd72adaa5313bd86b1211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f7256ed1d411e7c45b74875cc10d4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06f7256ed1d411e7c45b74875cc10d4e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_imagemesh</b> ()</td></tr>
<tr class="separator:a06f7256ed1d411e7c45b74875cc10d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e825ba9e608813ccac63d6dba70c38c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e825ba9e608813ccac63d6dba70c38c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_structquadsurfmesh</b> ()</td></tr>
<tr class="separator:a9e825ba9e608813ccac63d6dba70c38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16c2bfa013f34f4d2f140296260d5fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af16c2bfa013f34f4d2f140296260d5fb"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_tetvolmesh</b> ()</td></tr>
<tr class="separator:af16c2bfa013f34f4d2f140296260d5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c1cfc7b56eac5cd83c72fee5be4bc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16c1cfc7b56eac5cd83c72fee5be4bc9"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_prismvolmesh</b> ()</td></tr>
<tr class="separator:a16c1cfc7b56eac5cd83c72fee5be4bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c49807db2bca8b34aa0762e49001822"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c49807db2bca8b34aa0762e49001822"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_hexvolmesh</b> ()</td></tr>
<tr class="separator:a0c49807db2bca8b34aa0762e49001822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda3403bf64d9393a1264740c4cca129"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afda3403bf64d9393a1264740c4cca129"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_latvolmesh</b> ()</td></tr>
<tr class="separator:afda3403bf64d9393a1264740c4cca129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ef2db292f4d0d6e2888d2b35d01d82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35ef2db292f4d0d6e2888d2b35d01d82"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_structhexvolmesh</b> ()</td></tr>
<tr class="separator:a35ef2db292f4d0d6e2888d2b35d01d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab1f897594c0b502ecf8e632a7863c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaab1f897594c0b502ecf8e632a7863c7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#aaab1f897594c0b502ecf8e632a7863c7">is_constantmesh</a> ()</td></tr>
<tr class="memdesc:aaab1f897594c0b502ecf8e632a7863c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check order of mesh. <br/></td></tr>
<tr class="separator:aaab1f897594c0b502ecf8e632a7863c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af849305a48a455bf176ed47a4cbf4951"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af849305a48a455bf176ed47a4cbf4951"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_linearmesh</b> ()</td></tr>
<tr class="separator:af849305a48a455bf176ed47a4cbf4951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d0355530225259a509562f2f330c46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95d0355530225259a509562f2f330c46"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_quadraticmesh</b> ()</td></tr>
<tr class="separator:a95d0355530225259a509562f2f330c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c9bde367f57aa6da43283e2530e081"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42c9bde367f57aa6da43283e2530e081"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_cubicmesh</b> ()</td></tr>
<tr class="separator:a42c9bde367f57aa6da43283e2530e081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8627c6d0de1dc18965c7043389f74c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc8627c6d0de1dc18965c7043389f74c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_nonlinearmesh</b> ()</td></tr>
<tr class="separator:adc8627c6d0de1dc18965c7043389f74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5880eaf7c01d58cdc6d7b77b771f81b2"><td class="memTemplParams" colspan="2">template&lt;class VEC1 , class VEC2 &gt; </td></tr>
<tr class="memitem:a5880eaf7c01d58cdc6d7b77b771f81b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a5880eaf7c01d58cdc6d7b77b771f81b2">convert_vector</a> (VEC1 &amp;v1, VEC2 v2) const </td></tr>
<tr class="separator:a5880eaf7c01d58cdc6d7b77b771f81b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98fe5591906f4908a1574429cb08879"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ab98fe5591906f4908a1574429cb08879">basis_order</a> ()</td></tr>
<tr class="separator:ab98fe5591906f4908a1574429cb08879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663fe4de7eb17ede0ab4136fe45c8342"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a663fe4de7eb17ede0ab4136fe45c8342"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dimensionality</b> ()</td></tr>
<tr class="separator:a663fe4de7eb17ede0ab4136fe45c8342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2198732d16cab5b10bf5ca644bfa60ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2198732d16cab5b10bf5ca644bfa60ef"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_point</b> ()</td></tr>
<tr class="separator:a2198732d16cab5b10bf5ca644bfa60ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76af1eedcab20c3eafd900215f948dbc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76af1eedcab20c3eafd900215f948dbc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_line</b> ()</td></tr>
<tr class="separator:a76af1eedcab20c3eafd900215f948dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8508bc53f58563b7b7d045ea106d5295"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8508bc53f58563b7b7d045ea106d5295"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_surface</b> ()</td></tr>
<tr class="separator:a8508bc53f58563b7b7d045ea106d5295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6af835dfef633b8f72914d7aa24b280"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6af835dfef633b8f72914d7aa24b280"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_volume</b> ()</td></tr>
<tr class="separator:af6af835dfef633b8f72914d7aa24b280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb049813a8bb154e7e40a49d4404bf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3eb049813a8bb154e7e40a49d4404bf5"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>num_nodes_per_elem</b> ()</td></tr>
<tr class="separator:a3eb049813a8bb154e7e40a49d4404bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4570c8e6f28da7a8f5a9ae2106d0355a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4570c8e6f28da7a8f5a9ae2106d0355a"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>num_enodes_per_elem</b> ()</td></tr>
<tr class="separator:a4570c8e6f28da7a8f5a9ae2106d0355a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db3ccce2e9606a5d3f2ed89a97cdb99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4db3ccce2e9606a5d3f2ed89a97cdb99"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>num_edges_per_elem</b> ()</td></tr>
<tr class="separator:a4db3ccce2e9606a5d3f2ed89a97cdb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9193a783a11342721c0d3b434b6b0e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9193a783a11342721c0d3b434b6b0e8"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>num_faces_per_elem</b> ()</td></tr>
<tr class="separator:ac9193a783a11342721c0d3b434b6b0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f20f66b25b0340c27e66fce40d8183"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1f20f66b25b0340c27e66fce40d8183"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>num_nodes_per_face</b> ()</td></tr>
<tr class="separator:af1f20f66b25b0340c27e66fce40d8183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b566557021ba361fe2e5a5e1b6dcb0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b566557021ba361fe2e5a5e1b6dcb0e"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>num_nodes_per_edge</b> ()</td></tr>
<tr class="separator:a9b566557021ba361fe2e5a5e1b6dcb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf5677592555fdfa02b0790236eeb88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebf5677592555fdfa02b0790236eeb88"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>num_edges_per_face</b> ()</td></tr>
<tr class="separator:aebf5677592555fdfa02b0790236eeb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4662deb2bdc929eece0355d77374dfd9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4662deb2bdc929eece0355d77374dfd9"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>num_gradients_per_node</b> ()</td></tr>
<tr class="separator:a4662deb2bdc929eece0355d77374dfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf3066212a982d74931404c4278ec5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bf3066212a982d74931404c4278ec5d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_normals</b> ()</td></tr>
<tr class="separator:a0bf3066212a982d74931404c4278ec5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03ca05f088b01eb042a2f20bde4ee68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa03ca05f088b01eb042a2f20bde4ee68"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_editable</b> ()</td></tr>
<tr class="separator:aa03ca05f088b01eb042a2f20bde4ee68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5594ce7861127eab09c60a04b500d964"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5594ce7861127eab09c60a04b500d964"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_regularmesh</b> ()</td></tr>
<tr class="separator:a5594ce7861127eab09c60a04b500d964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46279e0df5aae45805d5148cad512b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa46279e0df5aae45805d5148cad512b9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_irregularmesh</b> ()</td></tr>
<tr class="separator:aa46279e0df5aae45805d5148cad512b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971eab40dd5dd4c380122092f8cc1a67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a971eab40dd5dd4c380122092f8cc1a67"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_structuredmesh</b> ()</td></tr>
<tr class="separator:a971eab40dd5dd4c380122092f8cc1a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d94bc2c96b7af0794e9319348e07b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78d94bc2c96b7af0794e9319348e07b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_unstructuredmesh</b> ()</td></tr>
<tr class="separator:a78d94bc2c96b7af0794e9319348e07b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad756bfbc117e3bebbdf67e446d2b4cb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad756bfbc117e3bebbdf67e446d2b4cb9"></a>
<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_ni</b> () const </td></tr>
<tr class="separator:ad756bfbc117e3bebbdf67e446d2b4cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8e2780ec28dfa12e6e1928ee657655"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d8e2780ec28dfa12e6e1928ee657655"></a>
<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_nj</b> () const </td></tr>
<tr class="separator:a0d8e2780ec28dfa12e6e1928ee657655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc8e1350354829abd694603e14c6598"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cc8e1350354829abd694603e14c6598"></a>
<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_nk</b> () const </td></tr>
<tr class="separator:a4cc8e1350354829abd694603e14c6598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bfbaed4830ca20867fb0f90b878029"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27bfbaed4830ca20867fb0f90b878029"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>generation</b> () const </td></tr>
<tr class="separator:a27bfbaed4830ca20867fb0f90b878029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac147e51684c5564380802b63e81cee2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ac147e51684c5564380802b63e81cee2f">from_index</a> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;i, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;j, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;k, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> idx)</td></tr>
<tr class="memdesc:ac147e51684c5564380802b63e81cee2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">From index splits up the index into parts.  <a href="#ac147e51684c5564380802b63e81cee2f">More...</a><br/></td></tr>
<tr class="separator:ac147e51684c5564380802b63e81cee2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0f7ad864d3a5a76eca76cdb7d54a65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e0f7ad864d3a5a76eca76cdb7d54a65"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>from_index</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;i, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;j, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;k, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> idx)</td></tr>
<tr class="separator:a1e0f7ad864d3a5a76eca76cdb7d54a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f8d495a3e7cc1fbe5f5f2b11b478f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35f8d495a3e7cc1fbe5f5f2b11b478f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>from_index</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;i, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;j, <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> idx)</td></tr>
<tr class="separator:a35f8d495a3e7cc1fbe5f5f2b11b478f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c5cc5d9844cfdcb18559953ff47a93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04c5cc5d9844cfdcb18559953ff47a93"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>from_index</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;i, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;j, <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> idx)</td></tr>
<tr class="separator:a04c5cc5d9844cfdcb18559953ff47a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86d05c746aa45dbe15991b30681058b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af86d05c746aa45dbe15991b30681058b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>from_index</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;i, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;j, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;k, <a class="el" href="struct_s_c_i_run_1_1_v_cell_index.html">Cell::index_type</a> idx)</td></tr>
<tr class="separator:af86d05c746aa45dbe15991b30681058b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d27cae3e55c5e1ba9e7dacdd90535a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3d27cae3e55c5e1ba9e7dacdd90535a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>from_index</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;i, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;j, <a class="el" href="struct_s_c_i_run_1_1_v_face_index.html">Face::index_type</a> idx)</td></tr>
<tr class="separator:ae3d27cae3e55c5e1ba9e7dacdd90535a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fba8b2b8f9504e67a9efe367931c1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97fba8b2b8f9504e67a9efe367931c1f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a97fba8b2b8f9504e67a9efe367931c1f">to_index</a> (<a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> &amp;idx, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> i, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> j, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> k)</td></tr>
<tr class="memdesc:a97fba8b2b8f9504e67a9efe367931c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">To index generates a new successive index. <br/></td></tr>
<tr class="separator:a97fba8b2b8f9504e67a9efe367931c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681703f8325e710d84b8f8ddb7c85ec8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a681703f8325e710d84b8f8ddb7c85ec8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>to_index</b> (<a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> &amp;idx, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> i, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> j)</td></tr>
<tr class="separator:a681703f8325e710d84b8f8ddb7c85ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2762b5f74ca09c55ce81b0b1f8580172"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2762b5f74ca09c55ce81b0b1f8580172"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>to_index</b> (<a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> &amp;idx, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> i, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> j, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> k)</td></tr>
<tr class="separator:a2762b5f74ca09c55ce81b0b1f8580172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa898d2de65047569cb84c5a65f2826ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa898d2de65047569cb84c5a65f2826ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>to_index</b> (<a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a> &amp;idx, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> i, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> j)</td></tr>
<tr class="separator:aa898d2de65047569cb84c5a65f2826ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b42e2fe821e5b47555c5551bd4b6b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05b42e2fe821e5b47555c5551bd4b6b0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>to_index</b> (<a class="el" href="struct_s_c_i_run_1_1_v_cell_index.html">Cell::index_type</a> &amp;idx, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> i, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> j, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> k)</td></tr>
<tr class="separator:a05b42e2fe821e5b47555c5551bd4b6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a93c204b06a859172e7704549bbf270"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a93c204b06a859172e7704549bbf270"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>to_index</b> (<a class="el" href="struct_s_c_i_run_1_1_v_face_index.html">Face::index_type</a> &amp;idx, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> i, <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> j)</td></tr>
<tr class="separator:a9a93c204b06a859172e7704549bbf270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb26572e340a70e6041e68fdd0c276a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fb26572e340a70e6041e68fdd0c276a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a8fb26572e340a70e6041e68fdd0c276a">is_pnt_element</a> ()</td></tr>
<tr class="memdesc:a8fb26572e340a70e6041e68fdd0c276a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for the type of elements. <br/></td></tr>
<tr class="separator:a8fb26572e340a70e6041e68fdd0c276a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad164ecb3a5d6e66b3b772b12b3f40bca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad164ecb3a5d6e66b3b772b12b3f40bca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_crv_element</b> ()</td></tr>
<tr class="separator:ad164ecb3a5d6e66b3b772b12b3f40bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09996bcd7575309336a171fd966a8627"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09996bcd7575309336a171fd966a8627"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_tri_element</b> ()</td></tr>
<tr class="separator:a09996bcd7575309336a171fd966a8627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacffd34bb91423b0e079381d5227937"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeacffd34bb91423b0e079381d5227937"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_quad_element</b> ()</td></tr>
<tr class="separator:aeacffd34bb91423b0e079381d5227937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540681e2d004ed96f0196ae59920b72d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a540681e2d004ed96f0196ae59920b72d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_tet_element</b> ()</td></tr>
<tr class="separator:a540681e2d004ed96f0196ae59920b72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425a3f96c0d521503fcb4598cef1692e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a425a3f96c0d521503fcb4598cef1692e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_prism_element</b> ()</td></tr>
<tr class="separator:a425a3f96c0d521503fcb4598cef1692e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c4cabd9f86ea5b99e99ce29999dfcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91c4cabd9f86ea5b99e99ce29999dfcc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_hex_element</b> ()</td></tr>
<tr class="separator:a91c4cabd9f86ea5b99e99ce29999dfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee497c94f91dc676d6dbd27f4888919"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ee497c94f91dc676d6dbd27f4888919"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a3ee497c94f91dc676d6dbd27f4888919">get_element_vertices</a> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ad682e81b4b76f2fb01404e31f92e3bb2">coords_array_type</a> &amp;coords)</td></tr>
<tr class="memdesc:a3ee497c94f91dc676d6dbd27f4888919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unit vertex coordinates of the unit element. <br/></td></tr>
<tr class="separator:a3ee497c94f91dc676d6dbd27f4888919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8df0785d1d996a955d42b21a5102ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e8df0785d1d996a955d42b21a5102ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_element_edges</b> (nodes_array_type &amp;edges)</td></tr>
<tr class="separator:a9e8df0785d1d996a955d42b21a5102ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcccabb10b327e0b801b2eafd90dc24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdcccabb10b327e0b801b2eafd90dc24"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_element_center</b> (<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;coords)</td></tr>
<tr class="separator:afdcccabb10b327e0b801b2eafd90dc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab554cb4fac9a5519c6a5e4ba1fa5a8d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab554cb4fac9a5519c6a5e4ba1fa5a8d2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>get_element_size</b> ()</td></tr>
<tr class="separator:ab554cb4fac9a5519c6a5e4ba1fa5a8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0058d36e7dfe56ab2dcdc99ca86530fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a0058d36e7dfe56ab2dcdc99ca86530fd">basis_order_</a></td></tr>
<tr class="separator:a0058d36e7dfe56ab2dcdc99ca86530fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848ec32c24f8a2a509d65abfbbe04d25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a848ec32c24f8a2a509d65abfbbe04d25"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dimension_</b></td></tr>
<tr class="separator:a848ec32c24f8a2a509d65abfbbe04d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027eed9c6ea6601cb15e76d1e910714e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a027eed9c6ea6601cb15e76d1e910714e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a027eed9c6ea6601cb15e76d1e910714e">has_normals_</a></td></tr>
<tr class="memdesc:a027eed9c6ea6601cb15e76d1e910714e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_s_c_i_run_1_1_mesh.html">Mesh</a> properties. <br/></td></tr>
<tr class="separator:a027eed9c6ea6601cb15e76d1e910714e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab094cd306797884a8cc3822d75937749"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab094cd306797884a8cc3822d75937749"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_editable_</b></td></tr>
<tr class="separator:ab094cd306797884a8cc3822d75937749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84f95923e729d7f3d701344a0a26fb7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab84f95923e729d7f3d701344a0a26fb7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_regular_</b></td></tr>
<tr class="separator:ab84f95923e729d7f3d701344a0a26fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac47a882b7e56c85ae0097f34a03775"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adac47a882b7e56c85ae0097f34a03775"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_structured_</b></td></tr>
<tr class="separator:adac47a882b7e56c85ae0097f34a03775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af243a3375fb7043ba4e9fdd7ce9a8fe2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af243a3375fb7043ba4e9fdd7ce9a8fe2"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#af243a3375fb7043ba4e9fdd7ce9a8fe2">num_nodes_per_elem_</a></td></tr>
<tr class="memdesc:af243a3375fb7043ba4e9fdd7ce9a8fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_s_c_i_run_1_1_mesh.html">Mesh</a> statistics. <br/></td></tr>
<tr class="separator:af243a3375fb7043ba4e9fdd7ce9a8fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179a39f32b0c8a54b5b9b15cd274a1ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a179a39f32b0c8a54b5b9b15cd274a1ea"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>num_enodes_per_elem_</b></td></tr>
<tr class="separator:a179a39f32b0c8a54b5b9b15cd274a1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfe9ec93853ccdf3fc7522ad4c61739"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cfe9ec93853ccdf3fc7522ad4c61739"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>num_edges_per_elem_</b></td></tr>
<tr class="separator:a3cfe9ec93853ccdf3fc7522ad4c61739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391f30c860cd5a7154bf21461d2dde55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a391f30c860cd5a7154bf21461d2dde55"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>num_faces_per_elem_</b></td></tr>
<tr class="separator:a391f30c860cd5a7154bf21461d2dde55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2289f28b647c2fbe834a50319707b528"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2289f28b647c2fbe834a50319707b528"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>num_nodes_per_face_</b></td></tr>
<tr class="separator:a2289f28b647c2fbe834a50319707b528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678398c8f9b1312159f747c7911ce921"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a678398c8f9b1312159f747c7911ce921"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>num_edges_per_face_</b></td></tr>
<tr class="separator:a678398c8f9b1312159f747c7911ce921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949b514605ed89d4cf24a93c07e1caee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a949b514605ed89d4cf24a93c07e1caee"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>num_gradients_per_node_</b></td></tr>
<tr class="separator:a949b514605ed89d4cf24a93c07e1caee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ad74557f9bf7b89be4b71b71f8f9cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41ad74557f9bf7b89be4b71b71f8f9cc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a41ad74557f9bf7b89be4b71b71f8f9cc">element_size_</a></td></tr>
<tr class="memdesc:a41ad74557f9bf7b89be4b71b71f8f9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in local coordinate system. <br/></td></tr>
<tr class="separator:a41ad74557f9bf7b89be4b71b71f8f9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8001ca7e234df4f347a4e543f35aa0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad8001ca7e234df4f347a4e543f35aa0"></a>
<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#ad682e81b4b76f2fb01404e31f92e3bb2">coords_array_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#aad8001ca7e234df4f347a4e543f35aa0">unit_vertices_</a></td></tr>
<tr class="memdesc:aad8001ca7e234df4f347a4e543f35aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions of local element topology. <br/></td></tr>
<tr class="separator:aad8001ca7e234df4f347a4e543f35aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ba57ef458b2ed988c90175f713946f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65ba57ef458b2ed988c90175f713946f"></a>
nodes_array_type&#160;</td><td class="memItemRight" valign="bottom"><b>unit_edges_</b></td></tr>
<tr class="separator:a65ba57ef458b2ed988c90175f713946f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f9a9d16d4ec2996c9031e6b3b28eb7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3f9a9d16d4ec2996c9031e6b3b28eb7"></a>
<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>unit_center_</b></td></tr>
<tr class="separator:ad3f9a9d16d4ec2996c9031e6b3b28eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57ec90855244120ab479be2e88d3a9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#aa57ec90855244120ab479be2e88d3a9e">ni_</a></td></tr>
<tr class="separator:aa57ec90855244120ab479be2e88d3a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094f75acf95e2695a5872e715a4034c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a094f75acf95e2695a5872e715a4034c1"></a>
<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nj_</b></td></tr>
<tr class="separator:a094f75acf95e2695a5872e715a4034c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237ea3569f6bbdbae20afd6519239db5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a237ea3569f6bbdbae20afd6519239db5"></a>
<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nk_</b></td></tr>
<tr class="separator:a237ea3569f6bbdbae20afd6519239db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae9dccc9a8e4b528497b1fd5118637e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ae9dccc9a8e4b528497b1fd5118637e"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a1ae9dccc9a8e4b528497b1fd5118637e">generation_</a></td></tr>
<tr class="memdesc:a1ae9dccc9a8e4b528497b1fd5118637e"><td class="mdescLeft">&#160;</td><td class="mdescRight">generation number of mesh <br/></td></tr>
<tr class="separator:a1ae9dccc9a8e4b528497b1fd5118637e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a69773be1fc8c5b47a4197be4a2c4aa00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_s_c_i_run_1_1_stack_vector.html">StackVector</a>&lt;double,3&gt; <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">SCIRun::VMesh::coords_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A stack vector is a faster class than vector but is limited to a maximum number of entries coords_type is used to denote the location inside an element in local coordinates </p>

</div>
</div>
<a class="anchor" id="a8b813c7746a5777053cad48af766af15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a>&gt; <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a8b813c7746a5777053cad48af766af15">SCIRun::VMesh::dimension_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dimensions of a mesh, these are used for the regular grids Irregular grids only have one dimension, namely the number of nodes or elements </p>

</div>
</div>
<a class="anchor" id="a6035940e63cb533cb69e5bee63cd53e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_s_c_i_run_1_1_stack_vector.html">StackVector</a>&lt;<a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a>,3&gt; <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a6035940e63cb533cb69e5bee63cd53e5">SCIRun::VMesh::dpoints_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Derivative of points each component contains the x,y, and z derivative of the point. This is used in higher order elements </p>

</div>
</div>
<a class="anchor" id="a312efb2415f3b0119d1d944c4131c312"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">StackBasedVector</a>&lt;<a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a>,12&gt; <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a312efb2415f3b0119d1d944c4131c312">SCIRun::VMesh::index_array_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A dual vector will store the first entries on the stack, if extra space is needed it will create vector to store data on. This way most operations are done directly from the stack, only in less common situations memory is allocated and is used to store data. Here we allow 12 spaces to be on the stack which should be enough. </p>

</div>
</div>
<a class="anchor" id="a319f4bbc40f3a52f7b1a5d9f072da0ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Mesh::index_type <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">SCIRun::VMesh::index_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VIRTUAL INTERFACE. </p>
<p>typedefs for <a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_node.html">Node</a>, <a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_edge.html" title="Class for indexing edges. ">Edge</a>, <a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_face.html" title="Class for indexing faces. ">Face</a> and <a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_cell.html">Cell</a> These are the basic types that we use, they are typedefed so we can alter the underlying type easily All indices are always of index_type </p>

</div>
</div>
<a class="anchor" id="aa7483757f655c7307a2b15c5f09effff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#aa7483757f655c7307a2b15c5f09effff">SCIRun::VMesh::mask_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mask type for setting bits. This one is set to special type to remind the user that only bit operations asre valid on masks </p>

</div>
</div>
<a class="anchor" id="a55178c395525bd261b30c878a0439981"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_elem_interpolate.html">ElemInterpolate</a>&gt; <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a55178c395525bd261b30c878a0439981">SCIRun::VMesh::MultiElemInterpolate</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We have special code for doing multiple interpolations at the same time all for speeding up the code and limit the number of virtual function calls. </p>

</div>
</div>
<a class="anchor" id="a9276f9dbec864e9fad74c4309a85ef71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Mesh::size_type <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">SCIRun::VMesh::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>size_type and index_type need to be the same but they have their own type to make the code more readable </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3a03c9840d8f57db514691dee8ab3fda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SCIRun::VMesh::VMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>instantiate the element information as these are protected the various derived constructors can fill these out. </p>
<p>This call is only made in DEBUG mode, to keep a record of all the objects that are being allocated and freed. </p>

</div>
</div>
<a class="anchor" id="a4500ee49d9bd5e482bd36053bfcfa1fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SCIRun::VMesh::~VMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor needs to be virtual to ensure that we can delete the full virtual interface from the <a class="el" href="class_s_c_i_run_1_1_v_mesh.html">VMesh</a> interface </p>
<p>This call is only made in DEBUG mode, to keep a record of all the objects that are being allocated and freed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6ccf16e86e122c4ce128814b8ccc365e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">VMesh::Node::index_type</a> SCIRun::VMesh::add_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do not use this one as it is not clear whether it is a element node or edge node </p>

</div>
</div>
<a class="anchor" id="ab98fe5591906f4908a1574429cb08879"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SCIRun::VMesh::basis_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inline calls to information that is constant for a mesh and does not change for a mesh. These properties are stored directly in the vmesh data structure and hence we can replace them by simple inline calls. </p>

</div>
</div>
<a class="anchor" id="ad5c8aa089892610ed8bff1ef4776e365"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SCIRun::VMesh::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_iterator.html">Node::iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>iterators for the virtual topology indices. These are not strictly needed but make the concepts in line with previous version. All iterators now go from 0 to number of elements, using consecutive unique numbers </p>

</div>
</div>
<a class="anchor" id="a5880eaf7c01d58cdc6d7b77b771f81b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VEC1 , class VEC2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SCIRun::VMesh::convert_vector </td>
          <td>(</td>
          <td class="paramtype">VEC1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VEC2&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used for local conversion of vector types At some point this function should go away </p>

</div>
</div>
<a class="anchor" id="a1bffa0b267b92834615f8c5e3e88f2c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SCIRun::VMesh::copy_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html">VMesh</a> *&#160;</td>
          <td class="paramname"><em>imesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_copy.html">Copy</a> nodes from one mesh to another mesh Note: currently only for irregular meshes TODO: Add regular meshes to the mix </p>

</div>
</div>
<a class="anchor" id="afe14e798576c9a5fa3aa026c2934f3ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VMesh::det_jacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The following functions are intended so one can do the local to global transformation efficiently. As the transformation matrix is a constant for certain meshes, it is precomputed and this function looks up the precomputed jacobians, while for others it depends on the element and it is computed on the fly. To assure that the fastest method is used, use these functions. Get the determinant of the jacobian matrix Coords determine where the determinant needs o be evaluated Generally LatVol, <a class="el" href="class_s_c_i_run_1_1_image_mesh.html">ImageMesh</a>, TriMesh, TetMesh have a jacobian that is independen of the local coordinate system, however HexVol, QuadSurf, and PrismVol have values that depend on the local position within the element </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#a94c3ee72a4bacfec323c57f9916f44e8">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="acbcf8798bfa3778f8356e23b3bfe55de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VMesh::find_closest_elem </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">VMesh::coords_type</a> &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">VMesh::Elem::index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the closest location that is part of an element This function returns the projection point on the mesh and the euclidian distance to the field which is the distance between point and the projection. It also returns the local coordinates of the element where the projection point is located and the element index. if no elements are found the function returns false. </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#ab47fbf91fde5092cb2065b3852809804">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a276b1f015861c0d1f2772b37e4f0ac1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VMesh::find_closest_elem </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">VMesh::coords_type</a> &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">VMesh::Elem::index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxdist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same function, but now limited to a certain search ratius. if no elements are found the function returns false. </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#a8d76b01e585a99a916d26b22e5db91bb">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5ba39e007efde392700db45ffd236cd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VMesh::find_closest_node </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">VMesh::Node::index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the closest point on a surface or a curve. </p>
<p>These functions return the closest node to a certain point It returns the distance and the node index and the location of the node. </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#a75f21a4d82fc1f408ab16c0ac4bb8485">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae4392ad70c719e8b36324d8586fc6ed9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VMesh::find_closest_node </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">VMesh::Node::index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxdist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This version uses a maximum radius for searching the node If no nodes are within radius the function returns false. </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#a9d5122586a92cfbb59aff3b7a9dde102">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aea9b3aa10bb9570564bd273ac90abb67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VMesh::find_closest_nodes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">VMesh::Node::index_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxdist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the nodes within a spherical region arounf point. It returns the indices to the nodes </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#aad4d83152b8f43608132d802b9c93314">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac147e51684c5564380802b63e81cee2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SCIRun::VMesh::from_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a319f4bbc40f3a52f7b1a5d9f072da0ff">index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>From index splits up the index into parts. </p>
<p>These functions help dealing with regular meshes and translate <a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_node.html">Node</a> indices to coordinate indices </p>

</div>
</div>
<a class="anchor" id="aa505685d9726303f7f9f088262ca8893"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::get_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Cell::array_type</a> &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the cell index that contains the specified component Depending on the geometry not every function may be available </p>

</div>
</div>
<a class="anchor" id="a7b38c6d318507015fc6d6edc475f0818"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SCIRun::VMesh::get_centers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a92441dd5102c545e55eaec85187b6562">points_type</a> &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the centers of a series of nodes, with points in an STL vector These just overload the function calls defined above. </p>

</div>
</div>
<a class="anchor" id="ab0d8979ac454b266d0cb67824a065374"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SCIRun::VMesh::get_constant_weights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>TODO: These should go: we have get_weights and get_derivate_weights with basis_order call Direct access to get weights functions in basis functions These four are for interpolation </p>

</div>
</div>
<a class="anchor" id="a57f4e1b5430388b1ef318acce48d2372"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::get_delems </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">DElem::array_type</a> &amp;&#160;</td>
          <td class="paramname"><em>delems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the derived element index that contains the specified component Depending on the geometry not every function may be available </p>

</div>
</div>
<a class="anchor" id="abfb76b716820326d46e39b4934e137e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::get_derivate_weights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>basis_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Old get_derivate_weights function, which returns weights but now for computing the gradient of a field. </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_mesh_shared.html#a6ccad99864974e638d70f6cf4761bc2e">SCIRun::VMeshShared&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4904774928ed3dc1b64fba281b5e9d66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::get_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a8b813c7746a5777053cad48af766af15">dimension_type</a> &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the dimensions of the mesh. This function will replace get_dim() </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#a8c83f5b6f363f96d19658fb22ab29268">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad99b719fe7551a8888d31cb77de80f3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::get_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Edge::array_type</a> &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the edges that make up an element or get the edges that contain certain nodes Depending on the geometry not every function may be available </p>

</div>
</div>
<a class="anchor" id="acaeb677f2077719f429dbebb5e448581"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::get_elems </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Elem::array_type</a> &amp;&#160;</td>
          <td class="paramname"><em>elems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the element index that contains the specified component Depending on the geometry not every function may be available </p>

</div>
</div>
<a class="anchor" id="a03b2066278f303abea48eae34ed2dcb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::get_enodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">ENode::array_type</a> &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the nodes that make up an element Depending on the geometry not every function may be available </p>

</div>
</div>
<a class="anchor" id="ab381b7fb5ac6ffff649208012c590e4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VMesh::get_epsilon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the epsilon for doing numerical computations This one is generally 1e-7*length diagonal of the bounding box </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_mesh_shared.html#a2e09b851629ae9c202694e80bf26cb7c">SCIRun::VMeshShared&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab5dc5176e9757e23ba9ec7e40994079f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::get_faces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Face::array_type</a> &amp;&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the faces that make up an element or get the faces that contain certain nodes or edges Depending on the geometry not every function may be available </p>

</div>
</div>
<a class="anchor" id="a6e8b71844f724b9c5a917cfb01c2312b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::get_gaussian_scheme </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">VMesh::coords_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These two functions specify a sampling scheme for interpolation, intergration etc. Currently it supports 3 <a class="el" href="class_s_c_i_run_1_1_gaussian.html">Gaussian</a> schemes that define the gaussian quadrature points for the meshes. Specify the order between 1 and 3. The regular sampling is intended for operations other than integration and sample using a regular scheme inside the element. Currently an order between 1 and 5 are supported to indicate the number of samples along one of the edges. Hence scheme 1 only gives one point in the center and scheme 5 can generate up to 125 sampling points depending on the topology of the element. </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_mesh_shared.html#a69dbce67a86a214aea7c598971cadc8c">SCIRun::VMeshShared&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a67b09dd591f6296d4bf84093d8a516bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::get_interpolate_weights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_elem_interpolate.html">ElemInterpolate</a> &amp;&#160;</td>
          <td class="paramname"><em>ei</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>basis_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialized functions to get weights for the interpolation One should use these instead of get_weights These functions fill out the interpolation structure, so that one can used in the code. The interpolation structures know about basis order and hence will do the right interpolation when given to a function of <a class="el" href="class_s_c_i_run_1_1_v_field.html">VField</a> for interpolation </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#a38a0c553e14273ae1420f021ef53fca5">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abc35b2afc08490f2948ea49e7a54fdc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SCIRun::VMesh::get_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_edge_index.html">Edge::index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>alternative ways to get the size values Again these are all defined inline so we do not get additional virtual calls in the interface an to reduce the overhead in the actual implementation of the virtual interface mesh classes. </p>

</div>
</div>
<a class="anchor" id="a13d686e46a85978bbbcb9d132ab3d299"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::get_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Topological functions: note that currently most meshes have an incomplete set implemented. Currently each mesh has: Getting cell, face, edge indices from node indices Getting the indices of the elements that are topologically building up the the element: e.g. one can derive faces from a cell index but not YET vice versa. Get the nodes that make up an element Depending on the geometry not every function may be available </p>

</div>
</div>
<a class="anchor" id="a37a7a6c384cd1f52f37f601e8a5b503a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::get_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_vector.html">Core::Geometry::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a>&#160;</td>
          <td class="paramname"><em>eidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_d_elem_index.html">DElem::index_type</a>&#160;</td>
          <td class="paramname"><em>fidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the normal to an element if this is a valid operation. This is only implemented for surface and volume meshes. As elements can be curved the coordinates specify where on the element one wants to compute the normal. This is the volumetric version where one has to specify as well which face is involved. </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#a6fed0b949371d20369143627562568f4">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7cda64c3da7ff79c384504e704f758c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SCIRun::VMesh::get_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the location of a point. As the old interface used both get_point and get_center, these are short cuts to the one implementation that is done under the name get_center. </p>

</div>
</div>
<a class="anchor" id="af4b675835ed87f5271dae318c49013b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Point</a> * VMesh::get_points_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These should only be used to speed up code within proper wrappers and after checking the type of the underlying mesh as they allow direct access to the mesh memory </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#af294a4d2b987422b1128f47427705334">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a22f2d53503f5bd473bfc6549f61703c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::get_random_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_field_r_n_g.html">FieldRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the location of a random point inside the mesh. </p>
<p>Set and get a node location. <a class="el" href="class_s_c_i_run_1_1_v_mesh_1_1_node.html">Node</a> set is only available for editable meshes </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#a6702b87183b4bdbb52b7c888b96b9bf2">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a473c3d97886aa31ca068d1b0a429a3a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SCIRun::VMesh::get_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the geometrical sizes of the mesh elements For nodes and enodes there is no size, hence predefine them in case some makes the call </p>

</div>
</div>
<a class="anchor" id="a417823d40d2cc250783a0fca744f1c6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VMesh::get_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">Node::array_type</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the size of an element. This function is intended to check for zero volume elements before adding an element to a mesh. </p>

</div>
</div>
<a class="anchor" id="a1b15e3a7a6a65b15e8d2f1e029c7d794"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::get_weights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>basis_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Old get_weights function, in this case the user needs to know about basis order and the basis order that is needed must be given. Also this function implies a certain ordering of the weights and this function only remains in order to provide a sense of backwards compatiblity. </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_mesh_shared.html#aa023ec10ddb9fce3aecd084efbf5ec82">SCIRun::VMeshShared&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1444093f1f7b4862b5aed558133fd3af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VMesh::inverse_jacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Ji</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the inverse jacobian matrix. This gives as side product the determinant of the inverse matrix. </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#a18fa3d1c8b97f21cb17e378b0356fd7f">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7979b424a86b11a5e8aa892f2e451936"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SCIRun::VMesh::is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>test for special case where the mesh is empty empty meshes may need a special treatment </p>

</div>
</div>
<a class="anchor" id="aa745269fbdfa92a940668c0d7cc89912"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::jacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a69773be1fc8c5b47a4197be4a2c4aa00">coords_type</a> &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the jacobian of the local to global transformation Note J needs to be a least an array of 9 values. Coords and idx again specify the element and the position in local coordinates. </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#a78dc85097f7dbd91f72b1d47ad1e8862">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abc7d05275282925ad4020b1577cce369"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VMesh::locate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">VMesh::Node::index_type</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Locate where a position is in the mesh The node version finds the closest node The element version find the element that contains the point </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#a8760b162a1c67a2187326e84d4df4d63">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0e9271421fd303bc510e1a8f7cde61d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VMesh::locate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_stack_based_vector.html">VMesh::Elem::array_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_b_box.html">Core::Geometry::BBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find elements that are inside or close to the bounding box. This function uses the underlying search structure to find candidates that are close. This functionality is general intended to speed up searching for elements in a certain region. </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#a33b4c57a23d5bfee7cf3d473918c4c25">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac08c624c6688736d10289800c8ed5279"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MeshHandle VMesh::mesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the mesh associated with the virtual interface These functions will return the respective mesh or vmesh class. </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_mesh_shared.html#a82ac6405180737c039d8d414200babaa">SCIRun::VMeshShared&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4f7e0189fb8abcbc2f09dc3089de9ca1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::mlocate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>multi locate functions. An 'm' in front of a function tends to denote that this function is vectorized for convenience. Depending on the underlying functionality it calls the single case multiple times or adds some optimization. In this case optimization occurs by assuming the points are close together and previous node or element indices are tested first to see if that is the index for the next one in the array Hence in optimal cases the search is reduced to a few points for a cloud of points </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#ae3ff779637e3ec7a818f1bedcdc76ab9">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a59a63db6f39f31a546defa5ffcb0d2fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::node_reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Preallocate memory for better performance We have two versions for historic reasons </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#ae15bd0b3903592d634cc8664b54f343a">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad973cfb27078f1dbaaf9bbced7ba7b25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a> SCIRun::VMesh::num_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We have been using the num_::type#() in other functions as well to determine the number of nodes, edges etc. These are just shortcuts to make porgrams more readable </p>

</div>
</div>
<a class="anchor" id="a3ec248c20592d8929b517ca7d99fedb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::resize_nodes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Actually resize the arrays. Note: this is limited to certain meshes </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#a6efa8ec7d6fb3e85d81e9b36b53dc85e">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae33196f0d2e9c2caa9042171e23d8793"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VMesh::scaled_jacobian_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_c_i_run_1_1_v_elem_index.html">Elem::index_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element Quality metrics: </p>
<p>Scaled jacobian of local to global transformation </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#a24028cd02643d0d9bc5d61703c300f2d">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abf10f8fce7a21d8dd922888775b89e33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::set_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_i_run_1_1_core_1_1_geometry_1_1_point.html">Core::Geometry::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::index_type</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the location of a point. Note: one must be the single user of the mesh to do this </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#aa1aec0f9b408162df50231f26d49db71">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab96ee649dad57ef154e54b22c282511a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VMesh::size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_c_i_run_1_1_v_node_index.html">Node::size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of elements in the mesh of the specified type Note: that for any size other then the number of nodes or elements, one has to synchronize that part of the mesh. </p>

<p>Reimplemented in <a class="el" href="class_s_c_i_run_1_1_v_unstructured_mesh.html#ad95183bbd1c633c15ec62dd8e37d073c">SCIRun::VUnstructuredMesh&lt; MESH &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a0058d36e7dfe56ab2dcdc99ca86530fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SCIRun::VMesh::basis_order_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Properties of meshes that do not change during the lifetime of the mesh and hence they can be stored for fast use. </p>

</div>
</div>
<a class="anchor" id="aa57ec90855244120ab479be2e88d3a9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c_i_run_1_1_v_mesh.html#a9276f9dbec864e9fad74c4309a85ef71">size_type</a> SCIRun::VMesh::ni_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>size of structured meshes unstructured mesh denote the number of nodes in ni_ </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Core/Datatypes/Legacy/Field/<a class="el" href="_v_mesh_8h_source.html">VMesh.h</a></li>
<li>Core/Datatypes/Legacy/Field/VMesh.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 6 2014 15:56:23 for SCIRun by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
