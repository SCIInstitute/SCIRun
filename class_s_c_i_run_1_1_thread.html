<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>SCIRun: SCIRun::Thread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SCIRun
   &#160;<span id="projectnumber">5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_s_c_i_run.html">SCIRun</a></li><li class="navelem"><a class="el" href="class_s_c_i_run_1_1_thread.html">Thread</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_s_c_i_run_1_1_thread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SCIRun::Thread Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_thread_8h_source.html">Thread.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af4147a1e69670365c86c83dfca7eb14b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#af4147a1e69670365c86c83dfca7eb14b">ActiveState</a> { <b>Activated</b>, 
<b>Stopped</b>, 
<b>NotActivated</b>
 }</td></tr>
<tr class="memdesc:af4147a1e69670365c86c83dfca7eb14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible thread start states. <br/></td></tr>
<tr class="separator:af4147a1e69670365c86c83dfca7eb14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a15c1b385051767e0ec1f32e404567a8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a15c1b385051767e0ec1f32e404567a8e">Thread</a> (Runnable *runner, const char *name, <a class="el" href="class_s_c_i_run_1_1_thread_group.html">ThreadGroup</a> *group=0, <a class="el" href="class_s_c_i_run_1_1_thread.html#af4147a1e69670365c86c83dfca7eb14b">ActiveState</a> state=Activated, unsigned long long stack_size=DEFAULT_STACKSIZE)</td></tr>
<tr class="separator:a15c1b385051767e0ec1f32e404567a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e979dee13590b1e578bcc2fa7ce2021"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e979dee13590b1e578bcc2fa7ce2021"></a>
<a class="el" href="class_s_c_i_run_1_1_thread_group.html">ThreadGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a4e979dee13590b1e578bcc2fa7ce2021">getThreadGroup</a> ()</td></tr>
<tr class="memdesc:a4e979dee13590b1e578bcc2fa7ce2021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <b><a class="el" href="class_s_c_i_run_1_1_thread_group.html">ThreadGroup</a></b> associated with this thread. <br/></td></tr>
<tr class="separator:a4e979dee13590b1e578bcc2fa7ce2021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84265c43b5805314433aff7e974d025"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad84265c43b5805314433aff7e974d025"></a>
Runnable *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#ad84265c43b5805314433aff7e974d025">getRunnable</a> ()</td></tr>
<tr class="memdesc:ad84265c43b5805314433aff7e974d025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <b>Runnable</b> associated with this thread. <br/></td></tr>
<tr class="separator:ad84265c43b5805314433aff7e974d025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783d1dbe29c789a4226adbcee66cf578"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a783d1dbe29c789a4226adbcee66cf578">setDaemon</a> (bool to=true)</td></tr>
<tr class="separator:a783d1dbe29c789a4226adbcee66cf578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a086da934ac3cb44e452e3b03da9a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0a086da934ac3cb44e452e3b03da9a0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#af0a086da934ac3cb44e452e3b03da9a0">isDaemon</a> () const </td></tr>
<tr class="memdesc:af0a086da934ac3cb44e452e3b03da9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the thread is tagged as a daemon thread. <br/></td></tr>
<tr class="separator:af0a086da934ac3cb44e452e3b03da9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae808a06d12a1a627f0825cdfc4b035cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#ae808a06d12a1a627f0825cdfc4b035cc">activate</a> (bool stopped)</td></tr>
<tr class="separator:ae808a06d12a1a627f0825cdfc4b035cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92d64c7e650e7d6d3a54f38decb5279"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#ab92d64c7e650e7d6d3a54f38decb5279">detach</a> ()</td></tr>
<tr class="separator:ab92d64c7e650e7d6d3a54f38decb5279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b231a7945957531c4524b3205c0d49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7b231a7945957531c4524b3205c0d49"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#ad7b231a7945957531c4524b3205c0d49">isDetached</a> () const </td></tr>
<tr class="memdesc:ad7b231a7945957531c4524b3205c0d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the thread is detached. <br/></td></tr>
<tr class="separator:ad7b231a7945957531c4524b3205c0d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8110016ba5c02dba028d963deddf6bbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a8110016ba5c02dba028d963deddf6bbb">setStackSize</a> (unsigned long long stackSize)</td></tr>
<tr class="separator:a8110016ba5c02dba028d963deddf6bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa46199dc3c7f31fcb0f5f9b4d4d934"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6aa46199dc3c7f31fcb0f5f9b4d4d934"></a>
unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a6aa46199dc3c7f31fcb0f5f9b4d4d934">getStackSize</a> () const </td></tr>
<tr class="memdesc:a6aa46199dc3c7f31fcb0f5f9b4d4d934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stack size for the thread. <br/></td></tr>
<tr class="separator:a6aa46199dc3c7f31fcb0f5f9b4d4d934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887a18dfc3e924b5917a5fff6df39445"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a887a18dfc3e924b5917a5fff6df39445"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a887a18dfc3e924b5917a5fff6df39445">stop</a> ()</td></tr>
<tr class="memdesc:a887a18dfc3e924b5917a5fff6df39445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the thread. <br/></td></tr>
<tr class="separator:a887a18dfc3e924b5917a5fff6df39445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c36816d1feed89591ebee13d3f8a1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4c36816d1feed89591ebee13d3f8a1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#af4c36816d1feed89591ebee13d3f8a1e">resume</a> ()</td></tr>
<tr class="memdesc:af4c36816d1feed89591ebee13d3f8a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume the thread. <br/></td></tr>
<tr class="separator:af4c36816d1feed89591ebee13d3f8a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1160245bcf8a0b11b574473156e3de62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a1160245bcf8a0b11b574473156e3de62">join</a> ()</td></tr>
<tr class="separator:a1160245bcf8a0b11b574473156e3de62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a209d9ef2996ffc8e9fed0bccbdeb93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a209d9ef2996ffc8e9fed0bccbdeb93"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a9a209d9ef2996ffc8e9fed0bccbdeb93">getThreadName</a> () const </td></tr>
<tr class="memdesc:a9a209d9ef2996ffc8e9fed0bccbdeb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the thread. <br/></td></tr>
<tr class="separator:a9a209d9ef2996ffc8e9fed0bccbdeb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956faa117178c39b22edceec25014ada"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a956faa117178c39b22edceec25014ada">migrate</a> (int proc)</td></tr>
<tr class="separator:a956faa117178c39b22edceec25014ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae8b4b16db0e20f037253d698bca45f05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8b4b16db0e20f037253d698bca45f05"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#ae8b4b16db0e20f037253d698bca45f05">exitAll</a> (int code)</td></tr>
<tr class="memdesc:ae8b4b16db0e20f037253d698bca45f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kill all threads and exit with <b>code</b>. <br/></td></tr>
<tr class="separator:ae8b4b16db0e20f037253d698bca45f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfb9d5b0f31ea891666dda51f16b877"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dfb9d5b0f31ea891666dda51f16b877"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a9dfb9d5b0f31ea891666dda51f16b877">exit</a> ()</td></tr>
<tr class="memdesc:a9dfb9d5b0f31ea891666dda51f16b877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit the currently running thread. <br/></td></tr>
<tr class="separator:a9dfb9d5b0f31ea891666dda51f16b877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c119671de88f2888c1dd6221c7c9fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2c119671de88f2888c1dd6221c7c9fe"></a>
static <a class="el" href="class_s_c_i_run_1_1_thread.html">Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#ae2c119671de88f2888c1dd6221c7c9fe">self</a> ()</td></tr>
<tr class="memdesc:ae2c119671de88f2888c1dd6221c7c9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the currently running thread. <br/></td></tr>
<tr class="separator:ae2c119671de88f2888c1dd6221c7c9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dae698f055b658d41a6407879439a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19dae698f055b658d41a6407879439a4"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a19dae698f055b658d41a6407879439a4">numProcessors</a> ()</td></tr>
<tr class="memdesc:a19dae698f055b658d41a6407879439a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of processors on the system. <br/></td></tr>
<tr class="separator:a19dae698f055b658d41a6407879439a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389b64ccd3d6e8605cf371b354e07fc1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_s_c_i_run_1_1_thread_group.html">ThreadGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a389b64ccd3d6e8605cf371b354e07fc1">parallel</a> (<a class="el" href="class_s_c_i_run_1_1_parallel_base.html">ParallelBase</a> &amp;helper, int nthreads, bool block, <a class="el" href="class_s_c_i_run_1_1_thread_group.html">ThreadGroup</a> *threadGroup=0)</td></tr>
<tr class="separator:a389b64ccd3d6e8605cf371b354e07fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeda0d599924201909460aef0a428e70"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abeda0d599924201909460aef0a428e70"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#abeda0d599924201909460aef0a428e70">parallel</a> (T *ptr, void(T::*pmf)(int), int numThreads)</td></tr>
<tr class="separator:abeda0d599924201909460aef0a428e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa798f043ca8ec65b97948757701008df"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa798f043ca8ec65b97948757701008df"></a>
template&lt;class T , class Arg1 &gt; </td></tr>
<tr class="memitem:aa798f043ca8ec65b97948757701008df"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#aa798f043ca8ec65b97948757701008df">parallel</a> (T *ptr, void(T::*pmf)(int, Arg1), int numThreads, Arg1 a1)</td></tr>
<tr class="memdesc:aa798f043ca8ec65b97948757701008df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Another overloaded version of parallel that passes 1 argument. <br/></td></tr>
<tr class="separator:aa798f043ca8ec65b97948757701008df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa923bd494720385b3a4c2eaf0518fc8"><td class="memTemplParams" colspan="2"><a class="anchor" id="afa923bd494720385b3a4c2eaf0518fc8"></a>
template&lt;class T , class Arg1 , class Arg2 &gt; </td></tr>
<tr class="memitem:afa923bd494720385b3a4c2eaf0518fc8"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#afa923bd494720385b3a4c2eaf0518fc8">parallel</a> (T *ptr, void(T::*pmf)(int, Arg1, Arg2), int numThreads, Arg1 a1, Arg2 a2)</td></tr>
<tr class="memdesc:afa923bd494720385b3a4c2eaf0518fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Another overloaded version of parallel that passes 2 arguments. <br/></td></tr>
<tr class="separator:afa923bd494720385b3a4c2eaf0518fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dddd2e60ca73f38f2259ac11a5f5be"><td class="memTemplParams" colspan="2"><a class="anchor" id="a72dddd2e60ca73f38f2259ac11a5f5be"></a>
template&lt;class T , class Arg1 , class Arg2 , class Arg3 &gt; </td></tr>
<tr class="memitem:a72dddd2e60ca73f38f2259ac11a5f5be"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a72dddd2e60ca73f38f2259ac11a5f5be">parallel</a> (T *ptr, void(T::*pmf)(int, Arg1, Arg2, Arg3), int numThreads, Arg1 a1, Arg2 a2, Arg3 a3)</td></tr>
<tr class="memdesc:a72dddd2e60ca73f38f2259ac11a5f5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Another overloaded version of parallel that passes 3 arguments. <br/></td></tr>
<tr class="separator:a72dddd2e60ca73f38f2259ac11a5f5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac374ac96414733aceb7631e4f18a0535"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac374ac96414733aceb7631e4f18a0535"></a>
template&lt;class T , class Arg1 , class Arg2 , class Arg3 , class Arg4 &gt; </td></tr>
<tr class="memitem:ac374ac96414733aceb7631e4f18a0535"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#ac374ac96414733aceb7631e4f18a0535">parallel</a> (T *ptr, void(T::*pmf)(int, Arg1, Arg2, Arg3, Arg4), int numThreads, Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4)</td></tr>
<tr class="memdesc:ac374ac96414733aceb7631e4f18a0535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Another overloaded version of parallel that passes 4 arguments. <br/></td></tr>
<tr class="separator:ac374ac96414733aceb7631e4f18a0535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b23477d36d6c09936a2ba24a2d1c42"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#ab7b23477d36d6c09936a2ba24a2d1c42">niceAbort</a> (void *Context=0)</td></tr>
<tr class="separator:ab7b23477d36d6c09936a2ba24a2d1c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2977620807ce94ac285405493b53ef5a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a2977620807ce94ac285405493b53ef5a">couldBlock</a> (const char *why)</td></tr>
<tr class="separator:a2977620807ce94ac285405493b53ef5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28eaa690f17e68827da60891584cbad"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#ac28eaa690f17e68827da60891584cbad">couldBlockDone</a> (int restore)</td></tr>
<tr class="separator:ac28eaa690f17e68827da60891584cbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65777f11634b8bf9b79d337b64e4992f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65777f11634b8bf9b79d337b64e4992f"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a65777f11634b8bf9b79d337b64e4992f">yield</a> ()</td></tr>
<tr class="memdesc:a65777f11634b8bf9b79d337b64e4992f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calling process voluntarily gives up time to another process. <br/></td></tr>
<tr class="separator:a65777f11634b8bf9b79d337b64e4992f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3440e40a04387c4207404b304df696a4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a3440e40a04387c4207404b304df696a4">isInitialized</a> ()</td></tr>
<tr class="separator:a3440e40a04387c4207404b304df696a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e2ba1e94d563ed5a127c71d846b385"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#a93e2ba1e94d563ed5a127c71d846b385">setDefaultAbortMode</a> (const char *abortMode)</td></tr>
<tr class="separator:a93e2ba1e94d563ed5a127c71d846b385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f321dbf3e519c604b7fa6654b66ccc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7f321dbf3e519c604b7fa6654b66ccc"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>initialize</b> ()</td></tr>
<tr class="separator:ac7f321dbf3e519c604b7fa6654b66ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aed0099b61100d52db244032a2f948b43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed0099b61100d52db244032a2f948b43"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Runnable</b></td></tr>
<tr class="separator:aed0099b61100d52db244032a2f948b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab270e49e575fdf0fe1a4f2ee911df116"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab270e49e575fdf0fe1a4f2ee911df116"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ConditionVariable</b></td></tr>
<tr class="separator:ab270e49e575fdf0fe1a4f2ee911df116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65943e7d20a5488ffce0e2c4b56d5f2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65943e7d20a5488ffce0e2c4b56d5f2e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>RecursiveMutex</b></td></tr>
<tr class="separator:a65943e7d20a5488ffce0e2c4b56d5f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0299a51a8b97fb3200509d92ba10fa2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0299a51a8b97fb3200509d92ba10fa2c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Mutex</b></td></tr>
<tr class="separator:a0299a51a8b97fb3200509d92ba10fa2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95be9530b663a7ede498565ad4eb1bd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95be9530b663a7ede498565ad4eb1bd8"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>Thread_private</b></td></tr>
<tr class="separator:a95be9530b663a7ede498565ad4eb1bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06795017a3bdefcc470704bd5a9ad0b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06795017a3bdefcc470704bd5a9ad0b1"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SystemCallManager</b></td></tr>
<tr class="separator:a06795017a3bdefcc470704bd5a9ad0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86d4937301f8120e54572ca46fb4f7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab86d4937301f8120e54572ca46fb4f7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Thread_run</b> (<a class="el" href="class_s_c_i_run_1_1_thread.html">Thread</a> *t)</td></tr>
<tr class="separator:ab86d4937301f8120e54572ca46fb4f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda7d6cf0fa4a6e9fb740776ce35732e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afda7d6cf0fa4a6e9fb740776ce35732e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Thread_shutdown</b> (<a class="el" href="class_s_c_i_run_1_1_thread.html">Thread</a> *, bool)</td></tr>
<tr class="separator:afda7d6cf0fa4a6e9fb740776ce35732e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0f0b4edf40bedd068e191ab757d558"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb0f0b4edf40bedd068e191ab757d558"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>run_threads</b> (void *priv_v)</td></tr>
<tr class="separator:aeb0f0b4edf40bedd068e191ab757d558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6c4490040d30bb34b89a10419a6a4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf6c4490040d30bb34b89a10419a6a4f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>handle_abort_signals</b> (int, siginfo_t *, void *)</td></tr>
<tr class="separator:acf6c4490040d30bb34b89a10419a6a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445de113625d75b6588113dc78870ca1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a445de113625d75b6588113dc78870ca1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>handle_quit</b> (int)</td></tr>
<tr class="separator:a445de113625d75b6588113dc78870ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5fcbbb5014fc85be53ac1f6a66061c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_i_run_1_1_thread.html#afd5fcbbb5014fc85be53ac1f6a66061c">handle_siguser2</a> (int)</td></tr>
<tr class="separator:afd5fcbbb5014fc85be53ac1f6a66061c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29773eb3416497ad94e6772373e20f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab29773eb3416497ad94e6772373e20f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>install_signal_handlers</b> ()</td></tr>
<tr class="separator:ab29773eb3416497ad94e6772373e20f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb33d11678d6b2a89ca3cb50c3eca19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3eb33d11678d6b2a89ca3cb50c3eca19"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>exit_handler</b> ()</td></tr>
<tr class="separator:a3eb33d11678d6b2a89ca3cb50c3eca19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_s_c_i_run_1_1_thread.html">Thread</a> class provides a new context in which to run. A single Runnable class is attached to a single <a class="el" href="class_s_c_i_run_1_1_thread.html">Thread</a> class, which are executed in another thread. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a15c1b385051767e0ec1f32e404567a8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SCIRun::Thread::Thread </td>
          <td>(</td>
          <td class="paramtype">Runnable *&#160;</td>
          <td class="paramname"><em>runner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_thread_group.html">ThreadGroup</a> *&#160;</td>
          <td class="paramname"><em>group</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_thread.html#af4147a1e69670365c86c83dfca7eb14b">ActiveState</a>&#160;</td>
          <td class="paramname"><em>state</em> = <code>Activated</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>stack_size</em> = <code>DEFAULT_STACKSIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a thread, which will execute the <b>run()</b> method in the <b>runner</b> object. The thread <b>name</b> is used for identification purposes, and does not need to be unique with respect to other threads. <b>Group</b> specifies the <a class="el" href="class_s_c_i_run_1_1_thread_group.html">ThreadGroup</a> that to which this thread should belong. If no group is specified (group==0), the default group is used. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae808a06d12a1a627f0825cdfc4b035cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SCIRun::Thread::activate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopped</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the thread is started in the the NotActivated state, use this to activate the thread (the argument should be false). </p>

</div>
</div>
<a class="anchor" id="a2977620807ce94ac285405493b53ef5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SCIRun::Thread::couldBlock </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>why</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mark a section as one that could block for debugging purposes. The <b>int</b> that is returned should be passed into <em><a class="el" href="class_s_c_i_run_1_1_thread.html#ac28eaa690f17e68827da60891584cbad">couldBlockDone(int)</a></em> when the section has completed. This will typically not be used outside of the thread implementation. </p>

</div>
</div>
<a class="anchor" id="ac28eaa690f17e68827da60891584cbad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SCIRun::Thread::couldBlockDone </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>restore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mark the end of a selection that could block. <em>restore</em> was returned from a previous invocation of the above <b>couldBlock</b>. </p>

</div>
</div>
<a class="anchor" id="ab92d64c7e650e7d6d3a54f38decb5279"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SCIRun::Thread::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Arrange to have the thread deleted automatically at exit. The pointer to the thread should not be used by any other threads once this has been called. </p>

</div>
</div>
<a class="anchor" id="a3440e40a04387c4207404b304df696a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool SCIRun::Thread::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the thread library has been initialized. This will typically not be used outside of the thread implementation. </p>

</div>
</div>
<a class="anchor" id="a1160245bcf8a0b11b574473156e3de62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SCIRun::Thread::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blocks the calling thread until this thead has finished executing. You cannot join detached threads or daemon threads. </p>

</div>
</div>
<a class="anchor" id="a956faa117178c39b22edceec25014ada"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SCIRun::Thread::migrate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>proc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request that the thread migrate to processor <em>proc</em>. If <em>proc</em> is -1, then the thread is free to run anywhere. </p>

</div>
</div>
<a class="anchor" id="ab7b23477d36d6c09936a2ba24a2d1c42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SCIRun::Thread::niceAbort </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Context</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Abort the current thread, or the process. Prints a message on stderr, and the user may choose one of: </p>
<pre>continue(c)/dbx(d)/cvd(v)/kill thread(k)/exit(e)</pre><p> context is necesary on Windows to catch a segfault </p>

</div>
</div>
<a class="anchor" id="a389b64ccd3d6e8605cf371b354e07fc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_c_i_run_1_1_thread_group.html">ThreadGroup</a>* SCIRun::Thread::parallel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_parallel_base.html">ParallelBase</a> &amp;&#160;</td>
          <td class="paramname"><em>helper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nthreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_c_i_run_1_1_thread_group.html">ThreadGroup</a> *&#160;</td>
          <td class="paramname"><em>threadGroup</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start up several threads that will run in parallel. A new <b><a class="el" href="class_s_c_i_run_1_1_thread_group.html">ThreadGroup</a></b> is created as a child of the optional parent. If <em>block</em> is true, then the caller will block until all of the threads return. Otherwise, the call will return immediately. </p>

</div>
</div>
<a class="anchor" id="abeda0d599924201909460aef0a428e70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SCIRun::Thread::parallel </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)(int)&#160;</td>
          <td class="paramname"><em>pmf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start up several threads that will run in parallel. If <em>block</em> is true, then the caller will block until all of the threads return. Otherwise, the call will return immediately. </p>

</div>
</div>
<a class="anchor" id="a783d1dbe29c789a4226adbcee66cf578"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SCIRun::Thread::setDaemon </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag the thread as a daemon thread. When all non-deamon threads exit, the program will exit. </p>

</div>
</div>
<a class="anchor" id="a93e2ba1e94d563ed5a127c71d846b385"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SCIRun::Thread::setDefaultAbortMode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>abortMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>set to "exit" (or something else) so we don't have to always wait for the user to input something </p>

</div>
</div>
<a class="anchor" id="a8110016ba5c02dba028d963deddf6bbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SCIRun::Thread::setStackSize </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>stackSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the stack size for a particular thread. In order to use this thread, you must create the thread in the NotActivated state, set the stack size, and then start the thread using activate(false). Setting the stack size for a thread that is running or has ever been run, will throw an exception. The units are in bytes. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="afd5fcbbb5014fc85be53ac1f6a66061c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handle_siguser2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make sure the exiting information is stored on the local stack In case we cannot access the structures any more</p>
<p>If not exiting tell we are running again </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Core/Thread/Legacy/<a class="el" href="_thread_8h_source.html">Thread.h</a></li>
<li>Core/Thread/Legacy/Thread_none.cc</li>
<li>Core/Thread/Legacy/Thread_pthreads.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 6 2014 15:56:32 for SCIRun by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
